---
title: "[Mattermost Integrations] Plugin"
---


## Mattermost Plugin

Mattermost Plugin は、Mattermost の様々な箇所に存在する拡張ポイントを使ってより幅広く、コアに近い部分に処理を差し込むことができる機能です。今まで紹介してきた統合機能に比べて、下記２点で優れていると個人的に思っています。

1. 投稿以外のユーザーの行動に対して独自の処理を追加することができる
2. Mattermost と同じサーバー上で動かすことができ、プロセス管理も Mattermost に任せられる

`1.`の点については、今まで紹介してきた統合機能は、メッセージの投稿や Slash Command の実行など Mattermost 上で投稿操作が行われた際に独自の処理を実行することができるというものでした。しかし、Plugin 機能では、ユーザーによる投稿操作の他にもチャンネル/チームへの参加/脱退やチャンネル作成時など、Mattermost 上の様々な操作に反応して独自の処理を実行させることができます。また、投稿操作についても、投稿がデータベースに保存される前後で処理を実行することができるため、投稿が作成される前に Reject するようなこともできます。

`2.`の点については WebSocket API を使うことで実現できたかもしれませんが、WebSocket API を始め Mattermost の統合機能を使うには、Mattermost とは別に統合機能からのリクエストを受け取るサーバーアプリケーションを構築しておく必要がありました。しかし、Mattermost Plugin は、そのプロセス管理を Mattermost 自身が行うため、Mattermost 以外のサーバーを管理する必要はありません。これが`2.`の利点です。さらに、Mattermost Plugin では Plugin 用の Key-Value ストアも用意されているため、簡単なデータの保持であれば Mattermost に任せることができます。

Mattermost Plugin は、サーバー側で動作する**Server**サイドのプラグインとブラウザ上で動作する**Webapp**サイドのプラグインがあります。一つの Plugin に両方の機能を持たせても良いですし、どちらか一方の機能だけの Plugin を実装することもできます。

## Mattermost Plugin の使用

まず、Mattermost Plugin を使ってみるところから紹介します。

今回は、私も開発に参加している Mattermost 上で投票機能を作成することができる[Matterpoll プラグイン](https://github.com/matterpoll/matterpoll)を手動でインストールしてみます。

https://github.com/matterpoll/matterpoll

![matterpoll](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day17/matterpoll.png)

### 設定

まず、Mattermost Plugin を使うには、**システムコンソール > プラグイン管理 > プラグインを有効にする**が`有効`になっている必要があります。

![config plugin](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day17/config-plugin.png)

また、手動でプラグインのインストールを行う場合、**システムコンソール > プラグイン管理 > プラグインをアップロードする**の`ファイルを選択する`が有効になっている必要があります。もし、このボタンが無効化されている場合は、Mattermost が起動しているサーバーの Mattermost インストールディレクトリにある`config/config.json`の`EnableUploads`を`true`にし、Mattermost を再起動する必要があります。

```config.json
    ...
    "PluginSettings": {
        "Enable": true,
        "EnableUploads": true,
    ...
```

### インストール

Plugin を使用する設定が完了したら、以下のページから`com.github.matterpoll.matterpoll-1.4.0.tar.gz`をダウンロードして、**システムコンソール > プラグイン管理 > プラグインをアップロードする**からアップロードします。

https://github.com/matterpoll/matterpoll/releases/tag/v1.4.0

(Matterpoll v1.4.0 は**Mattermost v5.20**以上を対象としているため、それより古いバージョンを使用している場合は、Matterpoll も古いバージョンのものをお使いください)

インストールが正常に終了すると、`インストール済みプラグイン`のところに Matterpoll が表示されます。Matterpoll プラグインのところにある`有効にする`のリンクをクリックすることでプラグインを有効にできます。

![install plugin](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day17/install-plugin.png)

### 実行

Matterpoll プラグインが問題なく起動できれば、Matterpoll の機能が利用できるようになっています。Matterpoll は Slash Command で投票を作成するため、チャンネルに戻り `/poll help` と打つと、Matterpoll のヘルプメッセージが出てきます。

![execute plugin](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day17/execute-plugin.png)

## Mattermost Plugin の開発

先ほども見たように、Mattermost Plugin の本体は`.tar.gz`ファイルになります。この`.tar.gz`ファイルには、プラグインのマニフェストファイルや、Server サイド機能のバイナリ、Webapp サイドの`.js`ファイルなどが含まれています。

毎回一からこれらを用意するのは大変なため、Mattermost チームは Mattermost Plugin 開発用のテンプレートリポジトリを公開しています。

https://github.com/mattermost/mattermost-plugin-starter-template

このテンプレートリポジトリを使った Mattermost Plugin の開発方法は、以下の記事で既に紹介しているため、ここでの説明は割愛します。

[Mattermost プラグイン用の GitHub リポジトリテンプレートを使ってみる \- Qiita](https://qiita.com/kaakaa_hoe/items/6f3d1aa0a126f2e94e01)

## Mattermost Demo Plugin

Mattermost Plugin では Mattermost の様々な箇所を拡張できますが、Plugin で拡張できる箇所を紹介する Demo 用のプラグインが公開されています。

https://github.com/mattermost/mattermost-plugin-demo

このプラグインをインストールすることで、全てではないですが Mattermost Plugin で拡張可能な箇所を確認できます。


## Mattermost Plugin (Server) について

**Server Hooks**の説明の前に、Mattermost Plugin の本体について紹介します。

Mattermost の**Server**サイドの Plugin を実装する場合、[`plugin.MattermostPlugin`](https://github.com/mattermost/mattermost-server/blob/f2571099539ee6e432d59e5bb4bc390652426a0e/plugin/client.go#L39)を埋め込んだ構造体が Plugin 本体となります。`plugin.MattermostPlugin`を埋め込んだ構造体は、`API`と`Helper`というフィールドを持ち、これらのフィールドを経由して Mattermost のリソースを処理する様々なメソッドを呼び出すことができます。また、`plugin.MattermostPlugin`を埋め込んだ構造体に対して**Server Hooks**と同じインターフェースを持つメソッドを実装することで、**Server Hooks**を利用することができるようになります。

```go
package main

import (
	"github.com/mattermost/mattermost-server/v5/plugin"
)

type SamplePlugin struct {
	plugin.MattermostPlugin
}

// OnActivate Hooksの実装
func (p *SamplePlugin) OnActivate() error {
    // `API`フィールドを通じたPlugin APIの呼び出し
	if err := p.API.RegisterCommand(&model.Command{
		Trigger: "sample-command",
	}); err != nil {
		return errors.Wrap(err, "failed to register  command")
	}
    return nil
}
```

`main`メソッドで`plugin.MattermostPlugin`を埋め込んだ構造体を引数として`plugin.ClientMain`メソッドを呼ぶことで、プラグインを起動することができます。

```go
package main

import (
	"github.com/mattermost/mattermost-server/v5/plugin"
)

func main() {
	plugin.ClientMain(&SamplePlugin{})
}
```

## Server Hooks

Mattermost Plugin の Server Hooks は、Mattermost 上でユーザーがチャンネルに参加したときや、ユーザーが Mattermost にログインしたときなど、何かのアクションに応じて実行される処理を追加できる機能です。
`plugin.MattermostPlugin`を埋め込んだ構造体に、Server Hooks と同じインターフェースを持つメソッドを実装することで利用可能になります。

Server Hooks の一覧は下記から確認できます。

https://developers.mattermost.com/extend/plugins/server/reference/#Hooks

### OnActivate

`OnActivate` は Plugin が起動したときに呼ばれる Hook です。Bot を使う Plugin の場合はこの Hook 内で Bot ユーザーを作成したり、Slash Command を使う Plugin なら SlashCommand の登録などを行います。(Plugin から登録した Slash Command は、通常の統合機能として作成した Slash Command と違い外部アプリケーションにリクエストは送信されません。Slash Command が実行された時の処理は、Server Hooks の`ExecuteCommand`で実装します。)

`error``が返却された場合は、プラグインが起動されません。

```go
func (p *SamplePlugin) OnActivate() error {
	// Botの登録
	bot := &model.Bot{
		Username:    "test-bot",
		DisplayName: "Sample Bot",
	}
	botUserID, appErr := p.Helpers.EnsureBot(bot)
	if appErr != nil {
		return errors.Wrap(appErr, "failed to ensure bot user")
	}
	p.botUserID = botUserID

	// Slash Commandの登録
	if err := p.API.RegisterCommand(&model.Command{
		Trigger:      "sample",
		AutoComplete: true,
	}); err != nil {
		return errors.Wrap(err, "failed to register  command")
	}

    return nil
}
```

### Implemented

`Implemented`は、Plugin が実装している Hook の名前を返すための Hooks です。しかし、実装されているのを見たことがないので、用途はないかもしれません。

```go
func (p *MatterpollPlugin) Implemented() ([]string, error) {
    return []string{"OnActivate", "Implemented"}, nil
}
```

### OnDeactivate

`OnDeactivate`はプラグインが停止された時に実行されます。

```go
func (p *MatterpollPlugin) OnDeactivate() error {
    p.clean()
    return nil
}
```

### OnConfigurationChange

Plugin 専用の設定が変更された際に実行されます。
Mattermost Plugin の[Manifest ファイル](https://developers.mattermost.com/extend/plugins/manifest-reference/)に`settings`を記述することで、Plugin 専用の設定画面を持つことができます。

![IMAGE](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day18/configuration-page.png)

`OnConfigurationChange`周りの処理は下記の Starter テンプレートのコードを流用すると良いです。
https://github.com/mattermost/mattermost-plugin-starter-template/blob/master/server/configuration.go

```go
type configuration struct {
	SampleSetting string
}

func (p *SamplePlugin) OnConfigurationChange() error {
	var configuration = new(configuration)

	// Load the public configuration fields from the Mattermost server configuration.
	if err := p.API.LoadPluginConfiguration(configuration); err != nil {
		return errors.Wrap(err, "failed to load plugin configuration")
	}

    p.setConfiguration(configuration)

	return nil
}
```

### ServeHTTP

Mattermost Plugin 専用のエンドポイントに対してリクエストが送信された時に実行されます。

Mattermost Plugin には Plugin ごとにエンドポイントが存在します。Mattermost が`https://example.com:8065`で起動していたとすると、`https://example.com:8065/plugins/{PLUGING_ID}`が Plugin 専用のエンドポイントになります。ここに送られたリクエストを処理するのが`ServeHTTP`です。

```go
func (p *SamplePlugin) ServeHTTP(c *plugin.Context, w http.ResponseWriter, r *http.Request) {
	fmt.Fprint(w, "Hello, world!")
}
```

[Interactive Message](https://docs.mattermost.com/developer/interactive-messages.html)などのリクエスト送信先を Plugin 用のエンドポイントにするなどの利用方法があります。

### ExecuteCommand

Plugin API の[`RegisterCommand`](https://developers.mattermost.com/extend/plugins/server/reference/#API.RegisterCommand)で登録されたコマンドが実行された時に処理されます。

```go
func (p *SamplePlugin) OnActivate() error {
	// Slash Commandの登録
	if err := p.API.RegisterCommand(&model.Command{
		Trigger:      "sample",
		AutoComplete: true,
	}); err != nil {
		return errors.Wrap(err, "failed to register  command")
	}

	return nil
}

func (p *SamplePlugin) ExecuteCommand(c *plugin.Context, args *model.CommandArgs) (*model.CommandResponse, *model.AppError) {
	return &model.CommandResponse{Text: "Hello by plugin"}, nil
}
```

### UserHasBeenCreated

`UserHasBeenCreated`は、ユーザーが新規に作成された場合に実行されます。
新しく参加したユーザーに Bot からメッセージを送る場合などに使用できます。

![IMAGE](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day18/user-has-been-created.png)

```go
func (p *SamplePlugin) UserHasBeenCreated(c *plugin.Context, user *model.User) {
	channel, appErr := p.API.GetDirectChannel(p.botUserID, user.Id)
	if appErr != nil {
		p.API.LogWarn("failed to get direct channel", "user_id1", p.botUserID, "user_id2", user.Id, "details", appErr.Error())
		return
	}
	if _, appErr := p.API.CreatePost(&model.Post{
		ChannelId: channel.Id,
		UserId:    p.botUserID,
		Message:   "Welcome to Our Mattermost!",
	}); appErr != nil {
		p.API.LogWarn("failed to create welcome post.", "channel_id", channel.Id, "details", appErr.Error())
	}
}
```

### UserWillLogIn

`UserWillLogIn`は、ユーザーがログインする直前に実行されます。

空文字以外の文字列を返すとログインが取り消されますが、現在のバージョンでは返却した文字列はユーザーには表示されず、ユーザー名とパスワードが合っていても`Enter a valid email or username and/or password`というメッセージが表示されてしまうようです。さらに、プラグインを管理できるユーザーがログアウトしてしまうと、前記のエラーでログインできず、利用可能な状態に戻すのが困難になってしまうかもしれないため、使用には注意が必要そうです。

```go
unc (p *SamplePlugin) UserWillLogIn(c *plugin.Context, user *model.User) string {
	if err := p.check(); err != nil {
		return err.Error()
	}
	return ""
}
```

### UserHasLoggedIn

`UserHasLoggedIn`は、ユーザーがログインした直後に実行されます。

前回ログアウト(オフライン)してから、7 日以上経過していた場合に Bot からメッセージを送信する場合などに利用できます。

![IMAGE](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day18/user-has-logged-in.png)

```go
func (p *SamplePlugin) UserHasLoggedIn(c *plugin.Context, user *model.User) {
	status, appErr := p.API.GetUserStatus(user.Id)
	if appErr != nil {
		p.API.LogWarn("failed to get user status", "user_id", user.Id, "details", appErr.Error())
		return
	}
	t := time.Unix(status.LastActivityAt/1000, status.LastActivityAt%1000)
	if status.Status == model.STATUS_OFFLINE && time.Now().After(t.AddDate(0, 0, 7)) {
		channel, appErr := p.API.GetDirectChannel(p.botUserID, user.Id)
		if appErr != nil {
			p.API.LogWarn("failed to get direct channel", "user_id1", p.botUserID, "user_id2", user.Id, "details", appErr.Error())
			return
		}
		if _, appErr := p.API.CreatePost(&model.Post{
			ChannelId: channel.Id,
			UserId:    p.botUserID,
			Message:   "Hi! :wave:",
		}); appErr != nil {
			p.API.LogWarn("failed to create post.", "channel_id", channel.Id, "details", appErr.Error())
		}
	}
}
```

### MessageWillBePosted

`MessageWillBePosted`は、投稿されたメッセージがデータベースに保存される前に実行されます。投稿を拒否したり、投稿内容を自動で編集したい場合などに利用できます。投稿作成時に拒否や編集以外の処理を実行する場合は、投稿がデータベースに保存された後に実行される`MessageHasBeenPosted`の利用が推奨されています。

投稿を拒否する場合は、２つ目の return 値に空でない文字列を指定します。一つ目の返却値の`*model.Post`には内容を編集した後の`*model.Post`を指定します。`nil`を指定した場合でも、引数で与えられた`*model.Post`が指定されたものと解釈されます。

```go
func (p *SamplePlugin) MessageWillBePosted(c *plugin.Context, post *model.Post) (*model.Post, string) {
	if strings.Contains(post.Message, "shit") || strings.Contains(post.Message, "💩") {
		return nil, "You can't use `shit` and 💩 on this server."
	}
	return nil, ""
}
```

![IMAGE](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day18/message-will-be-posted.png)

この Hook によって投稿が拒否された場合、ユーザーからはその拒否理由が見えないようなので、拒否基準を明文化したり、拒否理由を Bot から通知するなどの対応が必要そうです。

### MessageWillBeUpdated

`MessageWillBeUpdated`は、投稿済みのメッセージを編集した際、編集内容がデータベースに保存される直前に実行される処理です。
`MessageWillBePosted`とほぼ同じ内容のため、例は省略します。

```go
func (p *SamplePlugin) MessageWillBeUpdated(c *plugin.Context, newPost, oldPost *model.Post) (*model.Post, string) {
    ...
}
```

### MessageHasBeenPosted

`MessageHasBeenPosted`は、投稿がデータベースに保存された直後に実行される処理です。

特定のキーワードを含むメッセージが作成された場合に、特定のチャンネルに通知するようなコードは下記のようになります。
Bot が作成した投稿もこの Hook で処理されるため、考慮が漏れると処理が無限ループしてしまうため注意が必要です。また、非公開チャンネルの投稿なども処理されてしまうため、その点を考慮する必要もあります。

![IMAGE](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day18/message-has-been-posted.png)

```go
func (p *SamplePlugin) MessageHasBeenPosted(c *plugin.Context, post *model.Post) {
	postUrl := fmt.Sprintf("http://localhost:8065/_redirect/pl/%s", post.Id)
	if strings.Contains(post.Message, "mattermost") && post.UserId != p.botUserID {
		p.API.CreatePost(&model.Post{
			Message:   fmt.Sprintf("Post refered to `mattermost` is created. See [here](%s) ", postUrl),
			UserId:    p.botUserID,
			ChannelId: "su7w9z51atnspjufg1c73ijx8w",
		})
	}
}
```

### MessageHasBeedUpdated

`MessageHasBeenUpdated`は、投稿済みのメッセージを編集した際、編集内容がデータベースに保存された直後に実行される処理です。
こちらも`MessageHasBeenPosted`とほぼ同じ内容のため、例は省略します。

```go
func (p *SamplePlugin) MessageHasBeenUpdated(c *plugin.Context, newPost, oldPost *model.Post) {
    ...
}
```

### ChannelHasBeenCreated

`ChannelHasBeenCreated`は、チャンネルが作成された直後に実行されます。

チャンネルが作成されたことを`town-square`チャンネルに通知するコードは下記のようになります。この Hook についても、非公開チャンネルが作成された場合の考慮が必要になります。

![IMAGE](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day18/channel-has-been-created.png)

```go
func (p *SamplePlugin) ChannelHasBeenCreated(c *plugin.Context, channel *model.Channel) {
	if channel.Type != model.CHANNEL_OPEN {
		return
	}

	u, appErr := p.API.GetUser(channel.CreatorId)
	if appErr != nil {
		p.API.LogError("Failed to get user", "details", appErr)
		return
	}
	townSquare, appErr := p.API.GetChannelByName(channel.TeamId, model.DEFAULT_CHANNEL, false)
	if appErr != nil {
		p.API.LogError("Failed to get channel", "details", appErr)
		return
	}

	if _, appErr := p.API.CreatePost(&model.Post{
		Type:      model.POST_DEFAULT,
		ChannelId: townSquare.Id,
		UserId:    p.botUserID,
		Message:   fmt.Sprintf("Channel ~%s has been created by %s.", channel.Name, u.GetDisplayName(model.SHOW_USERNAME)),
	}); appErr != nil {
		p.API.LogError("Failed to create post", "details", appErr)
	}
}
```

### UserHasJoinedChannel

`UserHasJoinedChannel`は、ユーザーがチャンネルに参加した直後に実行されます。第３引数の`actor`は、他のユーザーがユーザーをチャンネルに追加した場合など、ユーザーをチャンネルに追加する処理を実行した人の情報が入ります。

チャンネルに新しく参加したユーザーに読んで欲しいリンクなどを通知する場合に利用できます。

![IMAGE](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day18/user-has-joined-channel.png)

```go
func (p *SamplePlugin) UserHasJoinedChannel(c *plugin.Context, channelMember *model.ChannelMember, actor *model.User) {
	if channelMember.ChannelId != TargetChannelID {
		return
	}
	p.API.SendEphemeralPost(actor.Id, &model.Post{
		ChannelId: channelMember.ChannelId,
		UserId:    p.botUserID,
		Message:   fmt.Sprintf("This chanels is for XXX user. You'd better to read [notes for this channel](%s).", UrlForNotes),
	})
}
```

### UserHasLeftChannel

`UserHasLeftChannel`は、ユーザーがチャンネルから脱退した直後に実行されます。
`UserHasJoinedChannel`とほぼ同じ内容のため、例は省略します。

```go
func (p *SamplePlugin) UserHasLeftChannel(c *plugin.Context, channelMember *model.ChannelMember, actor *model.User) {
    ...
}
```

### UserHasJoinedTeam

`UserHasJoinedTeam`は、ユーザーがチームに参加した直後に実行されます。
`UserHasJoinedChannel`とほぼ同じ内容のため、例は省略します。

```go
func (p *SamplePlugin) UserHasJoinedTeam(c *plugin.Context, teamMember *model.TeamMember, actor *model.User)  {
    ...
}
```

### UserHasLeftTeam

`UserHasLeftTeam`は、ユーザーがチャンネルから脱退した直後に実行されます。
`UserHasJoinedChannel`とほぼ同じ内容のため、例は省略します。

```go
func (p *SamplePlugin) UserHasLeftTeam(c *plugin.Context, teamMember *model.TeamMember, actor *model.User) {
    ...
}
```

### FileWillBeUploaded

`FileWillBeUploaded`は、メッセージ入力欄にファイルが添付された時に実行されます。ユーザーが投稿作成を実行する前にファイルが変換されます。

添付されたファイルの情報は第 2 引数の[`*model.FileInfo`](https://pkg.go.dev/github.com/mattermost/mattermost-server/v5/model#FileInfo)から、ファイルの内容は第 3 引数の`io.Reader`から取得できます。添付ファイルに変更を加えた場合は、第 4 引数の`io.Writer`に書き込みます。
また、ファイルの添付を拒否する場合は、2 つ目の返却値に空でない文字列を指定します。1 つ目の返却値の`*model.FileInfo`には内容を編集した後の`*model.FileInfo`を指定します。もしファイルを編集した場合、編集後のファイルサイズについては自動で更新されるため、`FileWillBeUploaded`内で計算する必要はありません。

画像にフィルタをかける例は下記のようになります。

![IMAGE](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day18/file-will-be-uploaded.png)

```go
func (p *SamplePlugin) FileWillBeUploaded(c *plugin.Context, info *model.FileInfo, file io.Reader, output io.Writer) (*model.FileInfo, string) {
	if info.IsImage() {
		// Decode original image
		img, _, err := image.Decode(file)
		if err != nil {
			p.API.LogWarn("failed to decode uploaded image", "details", err.Error())
			return nil, ""
		}
		// Draw original image
		base := image.NewRGBA(image.Rect(0, 0, img.Bounds().Dx(), img.Bounds().Dy()))
		draw.Draw(base, base.Bounds(), img, image.ZP, draw.Src)

		// Create green filter
		src := image.NewRGBA(image.Rect(0, 0, img.Bounds().Dx(), img.Bounds().Dy()))
		draw.Draw(src, src.Bounds(), &image.Uniform{color.RGBA{255, 128, 255, 128}}, image.ZP, draw.Src)

		// Mask original image
		mask := image.Rect(25, 25, base.Bounds().Dx()-25, base.Bounds().Dy()-25)
		draw.DrawMask(base, base.Bounds(), src, image.ZP, mask, image.ZP, draw.Over)

		// Write masked image
		png.Encode(output, base)
	}
	return info, ""
}
```

画像ファイルの Exif を削除するなどで利用することもできますが、処理自体は Mattermost サーバーにファイルが送られた後に実行されるため、注意が必要です。


## Mattermost Plugin API

Mattermost Server Plugin の開発に利用できる API の一覧は下記にあります。

https://developers.mattermost.com/extend/plugins/server/reference/

ユーザーやチャンネル、投稿などの操作については REST API とほぼ同様の機能を有しています。数が多いため全ては紹介しませんが、Server Plugin 特有の処理に関する API を紹介していこうと思います。

### GetConfig

`GetConfig`は、Mattermost Server のシステムコンソールの設定情報を取得します。

```go
siteURL := p.API.GetConfig().ServiceSettings.SiteURL
```

`p.API.GetConfig()`下記の`OnConfigurationChange`内で実行し、Plugin 構造体のフィールドとして保持しておくのが良いそうです。
https://github.com/mattermost/mattermost-plugin-starter-template/blob/master/server/configuration.go

### OpenInteractiveDialog

`OpenInteractiveDialog`は、第 16 日目の記事でも紹介した Interactive Dialog を Plugin から開くための API です。Interactive Dialog を開くには`TriggerId`というパラメータが必須であり、`TriggerId`は Slash Command 実行時、もしくは Interactive Message Button/Menu 実行時に送信されるリクエストからしか取得できません。

以下の例は Slash Command 実行時に Interactive Dialog を開き、入力された情報を整形して投稿を作成するコードです。

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day19/open-interactive-dialog.gif)

```go:plugin.go
func (p *SamplePlugin) ExecuteCommand(c *plugin.Context, args *model.CommandArgs) (*model.CommandResponse, *model.AppError) {
	appErr := p.API.OpenInteractiveDialog(model.OpenDialogRequest{
		TriggerId: args.TriggerId,
		URL:       fmt.Sprintf("%s/plugins/com.github.kaakaa.mattermost-plugin-starter-template/callback", *p.API.GetConfig().ServiceSettings.SiteURL),
		Dialog: model.Dialog{
			Title:       "Sample Plugin Dialog",
			SubmitLabel: "Submit",
			Elements: []model.DialogElement{
				{
					DisplayName: "タイトル",
					Name:        "title",
					Placeholder: "Title",
					Type:        "text",
				},
				{
					DisplayName: "Snippet",
					Name:        "snippet",
					Type:        "textarea",
				},
			},
		},
	})
	if appErr != nil {
		return nil, appErr
	}
	return &model.CommandResponse{}, nil
}
```

Interactive Dialog のリクエスト送信先を

```go
		URL:       fmt.Sprintf("%s/plugins/com.github.kaakaa.mattermost-plugin-starter-template/callback", *p.API.GetConfig().ServiceSettings.SiteURL),
```

のようにすることで、Plugin から開いた Interactive Dialog のリクエストを Plugin で処理することもできます。このリクエストの受信先として、Mattermost Plugin Server Hook である`ServeHTTP`を使って`/callback`のエンドポイントを受け取る処理を追加します。

````go:plugin.go
func (p *SamplePlugin) ServeHTTP(c *plugin.Context, w http.ResponseWriter, r *http.Request) {
	if r.URL.Path == "/callback" {
		defer r.Body.Close()
		request := model.SubmitDialogRequestFromJson(r.Body)
		t := request.Submission["title"]
		s := request.Submission["snippet"]
		p.API.CreatePost(&model.Post{
			UserId:    request.UserId,
			ChannelId: request.ChannelId,
			Message:   fmt.Sprintf("## %s\n\n```\n%s\n```", t, s),
		})
		return
	}
	fmt.Fprint(w, "Hello, world!")
}
````

このようにすることで、Interactive Dialog の起動からリクエストの処理までを Plugin だけで完結させることができます。

### PublishWebSocketEvent

`PublishWebSocketEvent`は、プラグイン独自の WebSoket イベントを送信する API です。

`PublishWebSocketEvent`は、3 つの引数を取ります。

- `event string`: WebSocket イベント名を指定します。実際に送信される WebSocket イベントには接頭辞として`custom_<PluginID>_`が付与されます
- `payload map[string]interface{}`: 送信されるデータの内容を指定します
- `broadcast *model.WebsocketBroadcast`: WebSocket を送信する対象を指定します
  - [`model.WebsocketBroadcast`](https://pkg.go.dev/github.com/mattermost/mattermost-server/v5/model#WebsocketBroadcast)で、ユーザー、チャンネル、チームを指定したり、受信対象から外すユーザーを指定したりできます

Webapp Plugin API の[`registerWebSocketEventHandler`](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerWebSocketEventHandler)と組み合わせることで、プラグイン内で WebSocket イベントに関する処理を完結させることができます。
この辺りの使用例は第 22 日目以降の記事で紹介する予定です。

### SendMail

`SendMail`は、Mattermost Plugin から HTML メールを送信する API です。システムコンソールで SMTP の設定が完了している必要があります。

Slash Command を実行した際にメールを送信する例は以下のようになります。

```go:plugin.go
func (p *SamplePlugin) ExecuteCommand(c *plugin.Context, args *model.CommandArgs) (*model.CommandResponse, *model.AppError) {
	appErr := p.API.SendMail(
		"test@example.com",
		"Sample Title",
		"<h1>Mail from plugin</h1><div><p>Sample Mail</p></div>")
	if appErr != nil {
		return nil, appErr
	}

	return &model.CommandResponse{}, nil
}
```

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day19/send-mail.jpg)

### KVGet / KVSet

`KVGet`, `KVSet`は、プラグインごとに割り当てられた Key Value ストアから値を取得、または値を設定する API です。Key Value ストアには`[]byte`型のデータを格納できるため、格納用データの構造体を作成し、`json.Marshal`で`[]byte`型のデータ化したものを出し入れするのが主な使い方になるのではないかと思います。

Key Value ストアを使用してカウンターを実装した例が以下になります。

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day19/kvget-kvset.gif)

```go:plugin.go
type counter struct {
	Count     int    `json:"count"`
	CreatedAt string `json:"created_at"`
}

func (p *SamplePlugin) ExecuteCommand(c *plugin.Context, args *model.CommandArgs) (*model.CommandResponse, *model.AppError) {
	// read data
	b, appErr := p.API.KVGet("counter")
	if appErr != nil {
		return nil, appErr
	}
	var ct counter
	if b == nil {
		// init if data is not found
		ct = counter{
			Count:     0,
			CreatedAt: time.Now().Format(time.RFC3339),
		}
	} else {
		if err := json.Unmarshal(b, &ct); err != nil {
			return nil, model.NewAppError("where", "id", nil, err.Error(), http.StatusInternalServerError)
		}
	}
	// count up
	ct.Count = ct.Count + 1
	b, err := json.Marshal(ct)
	if err != nil {
		return nil, model.NewAppError("where", "id", nil, err.Error(), http.StatusInternalServerError)
	}
	// set data
	if appErr := p.API.KVSet("counter", b); appErr != nil {
		return nil, appErr
	}

	return &model.CommandResponse{Text: fmt.Sprintf("counter: %d", ct.Count)}, nil
}
```

Key Value ストアを操作する API は`KVGet`, `KVSet`以外にも数多くあります。データを削除する`KVDelete`や、プラグイン内で保存済みのデータの`key`を取得する`KVList`、期間を指定して値を格納できる`KVSetWithExpiry`などがあります。また、同時に`KVSet`が実行された場合に不整合が起きないようにするため、Atomic な Key Value ストアの操作を強制するための`KVCompareAndSet`などもあります。

API の一覧については公式ドキュメントを参照してください。
https://developers.mattermost.com/extend/plugins/server/reference/

## Helpers

Mattermost Plugin API は数多くあるため、Mattermost に対するほとんどの操作を実行することはできますが、より簡単に Plugin API を実行するための Helper 関数がいくつか存在します。

ここでは、Helper 関数のうち一部を紹介します。

Helper 関数の一覧は下記の公式ドキュメントにあります。
https://developers.mattermost.com/extend/plugins/server/reference/#Helpers

### KVGetJSON / KVSetJSON

先ほどの`KVGet`、`KVSet`のコードでは、構造体を`[]byte`に変換するために`KVSet`を呼ぶ前に`json.Marshal`を、`KVGet`を呼んだ後に`json.Unmarshal`を呼んでいましたが、`KVGetJSON`、`KVSetJSON`を使用することで、その必要がなくなります。

そのため、先ほどの処理を多少すっきりと書くことができます。

```go:plugin.go
type counter struct {
	Count     int    `json:"count"`
	CreatedAt string `json:"created_at"`
}

func (p *SamplePlugin) ExecuteCommand(c *plugin.Context, args *model.CommandArgs) (*model.CommandResponse, *model.AppError) {
	// read data
	var ct counter
	exists, err := p.Helpers.KVGetJSON("counter", &ct)
	if err != nil {
		return nil, model.NewAppError("where", "id", nil, err.Error(), http.StatusInternalServerError)
	}
	if !exists {
		ct = counter{
			Count:     0,
			CreatedAt: time.Now().Format(time.RFC3339),
		}
	}

	// count up
	ct.Count = ct.Count + 1

	// set data
	if appErr := p.Helpers.KVSetJSON("counter", ct); appErr != nil {
		return nil, model.NewAppError("where", "id", nil, err.Error(), http.StatusInternalServerError)
	}

	return &model.CommandResponse{Text: fmt.Sprintf("counter: %d", ct.Count)}, nil
}
```

### CheckRequiredServerConfiguration

`CheckRequiredServerConfiguration`は、システムコンソールの設定をチェックするための Helper 関数です。

引数に指定した[`model.Config`](https://pkg.go.dev/github.com/mattermost/mattermost-server/v5/model#Config)と同じ設定になっているかをチェックし、異なる設定だった場合は`false`を返します。

**システムコンソール > Bot アカウント > Bot アカウントの作成を有効にする**の設定が有効になっていない場合にプラグインの起動を停止するような例は以下のようになります。

```go:plugin.go
func toPtr(v bool) *bool {
	return &v
}

func (p *SamplePlugin) OnActivate() error {
	b, err := p.Helpers.CheckRequiredServerConfiguration(&model.Config{
		ServiceSettings: model.ServiceSettings{
			EnableBotAccountCreation: toPtr(true),
		},
	})
	if err != nil {
		return err
	}
	if !b {
		return errors.New("EnableBotAccountCreation must be true.")
	}

    ...
```

プラグイン起動時、サーバーのログには以下のようなログが出力されます。

```bash
2020-12-13T00:16:01.409+0900    error   mlog/log.go:229 Unable to restart plugin on upgrade.    {"path": "/api/v4/plugins", "request_id": "u31bzwuyhbyibratzznjxgxzrr", "ip_addr": "::1", "user_id": "87x93uo8pfnzdro9ktcmobpa1r", "method": "POST", "err_where": "installExtractedPlugin", "http_code": 500, "err_details": "EnableBotAccountCreation must be true."}
```


## Mattermost Plugin (Webapp) について

Mattermost Plugin (Webapp) の本体について紹介します。

Mattermost の**Webapp**サイドの Plugin を実装する場合、プラグイン本体は`registry`と`store`を引数にとる`initialize`メソッドを持つクラスです。`registry`は Mattermost Plugin (Webapp)の機能を呼び出すためのメソッドを持つオブジェクトで、`store`は Mattermost のデータにアクセスするためのインターフェースです。

公式ドキュメントでは、以下のような`PluginClass`が紹介されています。
https://developers.mattermost.com/extend/plugins/webapp/reference/

```js
class PluginClass {
    /**
    * initialize is called by the webapp when the plugin is first loaded.
    * Receives the following:
    * - registry - an instance of the registry tied to your plugin id
    * - store - the Redux store of the web app.
    */
    initialize(registry, store)

    /**
    * uninitialize is called by the webapp if your plugin is uninstalled
    */
    uninitialize()
}
```

この`PluginClass`のインスタンスを`window`オブジェクトが持つ`registerPlugin`関数に Plugin ID と共に与えることで、Plugin が有効になります。

```js
window.registerPlugin("myplugin", new PluginClass());
```

## Webapp Plugin API

### [registerRootComponent](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerRootComponent)

`registerRootComponent`は、画面全体に表示されるモーダルの React Component を登録する API です。Component が登録されると、Component を一意に識別するための ID が返却されます。

ここで登録した Root Component は、登録するだけで表示されるわけではなく、別のアクションから起動されることで表示されます。

登録された Component で使用できる props は特にありません。[channel_controller.jsx](https://github.com/mattermost/mattermost-webapp/blob/61a4de5e36f994955bacc47c8d56734f9a699a5a/components/channel_layout/channel_controller.jsx#L86)

今回は、チャンネルのヘッダー部分にボタンを追加する`registerChannelHeaderButtonAction` API を使って Root Component を表示する例を以下に示します。全てのプログラムを記述すると非常に長くなってしまうため、Redux によるデータのやりとりなど部分については本記事では割愛します。プログラム全体について知りたい場合は、[kaakaa/mattermost-plugin-api-sample](https://github.com/kaakaa/mattermost-plugin-api-sampleを参照してください。)
また、Mattermost 公式チームにより作成されているデモ用プラグイン[mattermost-plugin-demo](https://github.com/mattermost/mattermost-plugin-demo/tree/master/webapp)の実装も参考になります。

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day20/root-component.gif)

```js
...

import {openRootModal} from './actions'
import reducer from './reducer';

import Root from './components/root';

...

export default class Plugin {
    initialize(registry, store) {
        // (1) Root Componentの登録
        registry.registerRootComponent(Root)

        // (2) Root Componentを呼び出すアクションの登録
        registry.registerChannelHeaderButtonAction(
            channelHeaderButtonIcon,
            () => store.dispatch(openRootModal()),
            "Open Root modal","Open Root modal"
        );

        registry.registerReducer(reducer);
    }
}
```

上記の例では、`(1)`で Root Component となる React Component を登録し、`(2)`で Root Component を表示するアクションをチャンネルヘッダーボタンに与えています。`(2)`の`store.dispatch(openRootModal())`が Root Component を表示する処理ですが、これは Root Component を表示する state を流す処理になります。

Root Component は以下のようなコードであり、`visible = true`となることで画面に表示されます。

```js
import React from "react";

const Root = ({ visible, close }) => {
  if (!visible) {
    return null;
  }

  const style = getStyle();

  return (
    <div style={style.backdrop} onClick={close}>
      <div style={style.modal}>
        <p>Root modal</p>
      </div>
    </div>
  );
};

Root.propTypes = {
  visible: PropTypes.bool.isRequired,
  close: PropTypes.func.isRequired,
};

const getStyle = () => ({
  backdrop: {
    position: "absolute",
    display: "flex",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: "rgba(0, 0, 0, 0.50)",
    zIndex: 2000,
    alignItems: "center",
    justifyContent: "center",
  },
  modal: {
    height: "300px",
    width: "500px",
    padding: "1em",
    color: "black",
    backgroundColor: "white",
  },
});

export default Root;
```

Root Component は React Component のため、様々な要素を表示することができますが、基本的には通知のために利用し、ユーザーに入力を促すようなユースケースの場合は[`Interactive Dialog`](https://docs.mattermost.com/developer/interactive-dialogs.html)を使用すべきだと思います。

### [registerPopoverUserAttributesComponent](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerPopoverUserAttributesComponent)

`registerPopoverUserAttributesComponent`は、ユーザーアイコンをクリックすると表示される popover 内に表示される Component を登録します。

Mattermost 外からユーザーの情報を取得して表示する際に使用できます。所属の名称がコロコロ変わる会社などで LDAP から所属を引いて表示しておくと便利です。

登録した Component は以下の props を受け取れます。[profile_popover.jsx](https://github.com/mattermost/mattermost-webapp/blob/61a4de5e36f994955bacc47c8d56734f9a699a5a/components/profile_popover/profile_popover.jsx#L356)

- `user`: popover で表示しているユーザーのオブジェクト
  - アクセスできるのは[User](https://github.com/mattermost/mattermost-server/blob/master/model/user.go#L68)モデルで定義されている情報になると思います
  - `User`モデルで`omitempty`となっているものは空の場合除外されるため、値がある場合のみアクセスできます
- `hide`: popover を閉じる関数
- `status`: popover で表示しているユーザーの status
  - `online`, `offline`などの単なる文字列のようです

ここでは、固定文字列を表示する例を示します。

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day20/user-attribute.png)

```js:index.js
...

import UserAttributes from './components/user_attributes'

...

export default class Plugin {
    // eslint-disable-next-line no-unused-vars
    initialize(registry, store) {
		...
        // (1) User Popoverに説明を追加するComponentの登録
		registry.registerPopoverUserAttributesComponent(UserAttributes)
		...
    }
}
```

```js:components/user_attributes.jsx
import React from 'react';
import PropTypes from 'prop-types';

const UserAttributes = ({user, hide, status}) => {
    console.log("user", user.id);
    return (
        <div>
            <p>{'UserId: ' + user.id}</p>
        </div>
    );
}

UserAttributes.propTypes = {
    user: PropTypes.object.isRequired,
    hide: PropTypes.func.isRequired,
    status: PropTypes.object.isRequired,
};

export default UserAttributes;
```

### [registerPopoverUserActionsComponent](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerPopoverUserActionsComponent)

`registerPopoverUserActionsComponent`は、ユーザーアイコンをクリックすると表示される popover 内に表示される Component を登録します。`registerPopoverUserAttributesComponent`と似ていますが、表示される位置が異なるだけの違いだと思います。

登録した Component は、`registerPopoverUserAttributesComponent`と同じく以下の props を受け取れます。[profile_popover.jsx](https://github.com/mattermost/mattermost-webapp/blob/61a4de5e36f994955bacc47c8d56734f9a699a5a/components/profile_popover/profile_popover.jsx#L483)

- `user`: popover で表示しているユーザーのオブジェクト
- `hide`: popover を閉じる関数
- `status`: popover で表示しているユーザーの status

`registerPopoverUserActionsComponent`で、RootComponent を表示する例は以下のようになります。（処理を一部割愛しているため、プログラム全体は https://github.com/kaakaa/mattermost-plugin-api-sample から確認してください）

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day20/user-action.gif)

```js:index.js
...
import UserAction from './components/user_action';
...
export default class Plugin {
    // eslint-disable-next-line no-unused-vars
    initialize(registry, store) {
		...
        // User Popoverにアクションを追加するComponentの登録
		registry.registerPopoverUserActionsComponent(UserAction)
		...
	}
}
```

```js:components/user_action/user_action.jsx
import React from 'react';
import PropTypes from 'prop-types';

const UserActionComponent = ({openRootModal, user, hide, status}) => {
	const onClick = () => {
		openRootModal();
		hide();
	};
    return (
        <div>
            <p>User Action <button onClick={onClick}>Action</button></p>
        </div>
    )
};

UserActionComponent.PropTypes = {
	openRootModal: PropTypes.func.isRequired,
    user: PropTypes.object.isRequired,
    hide: PropTypes.func.isRequired,
    status: PropTypes.object.isRequired,
};

export default UserActionComponent;
```

### [registerLeftSidebarHeaderComponent](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerLeftSidebarHeaderComponent)

`registerLeftSidebarHeaderComponent`は、Mattermost 画面の左サイドバーに表示する Component を登録します。

登録された Component で使用できる props は特にありません。[sidebar.tsx](https://github.com/mattermost/mattermost-webapp/blob/61a4de5e36f994955bacc47c8d56734f9a699a5a/components/sidebar/sidebar.tsx#L179)

常に表示されている部分のため、職場の室温や CO2 濃度などを表示するなどの利用方法があるかと思います。

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day20/left-sidebar-header.png)

```js:index.js
...
import LeftSidebarHeader from './components/left_sidebar_header';
...
export default class Plugin {
    // eslint-disable-next-line no-unused-vars
    initialize(registry, store) {
		...
        // User Popoverにアクションを追加するComponentの登録
		registry.registerLeftSidebarHeaderComponent(LeftSidebarHeader)
		...
	}
}
```

```js:components/left_sidebar_header.jsx
import React from 'react';

const LeftSidebarHeaderComponent = () => {
	const style = {
		color: 'white',
	};
    return (
        <div style={style}>
            <p>left sidear header</p>
        </div>
    );
}

export default LeftSidebarHeader;
```

### [registerBottomTeamSidebarComponent](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerBottomTeamSidebarComponent)

`registerBottomTeamSidebarComponent`は、チーム選択サイドバーの下部に表示される Component を登録します。１つのチームにしか参加していない場合、チーム選択サイドバー自体が表示されないため、ここで登録した Component も表示されません。

登録された Component で使用できる props は特にありません。[legacy_team_sidebar_controller.tsx](https://github.com/mattermost/mattermost-webapp/blob/61a4de5e36f994955bacc47c8d56734f9a699a5a/components/legacy_team_sidebar/legacy_team_sidebar_controller.tsx#L283)

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day20/bottom-team-sidebar.png)

```js:index.js
...
import BottomTeamSidebar from './components/bottom_team_sidebar';
...
export default class Plugin {
    // eslint-disable-next-line no-unused-vars
    initialize(registry, store) {
		...
        // User Popoverにアクションを追加するComponentの登録
		registry.registerLeftSidebarHeaderComponent(BottomTeamSidebar)
		...
	}
}
```

```js:components/bottom_team_sidebar.jsx
import React from 'react';

const BottomTeamSidebarComponent = () => (
    <>
        <a href="https://github.com/">
            <i
                className='icon fa fa-github'
                style={{color: 'white'}}
            />
        </a>
    </>
);

export default BottomTeamSidebarComponent;
```

### [registerLinkTooltipComponent](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerLinkTooltipComponent)

`registerLinkTooltipComponent`は、リンクを hover した時に表示される tooltip の Component を登録します。

登録した Component は以下の props を受け取れます。[link_tooltip.tsx](https://github.com/mattermost/mattermost-webapp/blob/cc4ba4576ad978d2a29e6c51c3f12966d121f0d6/components/link_tooltip/link_tooltip.tsx#L113)

- `href`: hover しているリンクの URL
- `show`: tooltip が表示されているかどうかのフラグ

以下の例では単に hover しているリンクの URL を表示しているだけですが、リンク先から情報を取得して表示するようなこともできます。

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day20/link-tooltip.png)

```js:index.js
...
import LinkTooltip from './components/link_tooltip';
...
export default class Plugin {
    // eslint-disable-next-line no-unused-vars
    initialize(registry, store) {
		...
        // User Popoverにアクションを追加するComponentの登録
		registry.registerLinkTooltipComponent(LinkTooltip)
		...
	}
}
```

```js:components/link_tooltip.jsx
import React from 'react';
import PropTypes from 'prop-types';

const LinkTooltipComponent = ({href}) => {
    return (
        <>
            <p style={{
                backgroundColor: 'white',
                color: 'black',
                padding: '25px',
                border: '1px solid red',
            }}>
                {href}
            </p>
        </>
    )
}

LinkTooltipComponent.propTypes = {
    href: PropTypes.string.isRequired,
};

export default LinkTooltipComponent;
```

### [registerChannelHeaderButtonAction](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerChannelHeaderButtonAction)

`registerChannelHeaderButtonAction`は、`registerRootComponent`のところでも使用しましたが、チャンネルのヘッダ部分にアクション付きのボタンを登録します。

`registerChannelHeaderButtonAction`は、`(icon, action, dropdownText, tooltipText)`の４つの引数を取ります。

- `icon`: ボタンのアイコンを表す React Element
- `action`: ボタンがクリックされたときに実行されるアクション
  - ボタンが押されたチャンネルの情報を持つ[`channel`](https://github.com/mattermost/mattermost-server/blob/master/model/channel.go#L36)と、ボタンを押したユーザーの[`channelMember`](https://github.com/mattermost/mattermost-server/blob/master/model/channel_member.go#L44)を引数に取ることができます
- `dropdown_text`: ボタンが複数登録されると一つのアイコンにまとめられ、ドロップダウンメニューから選ぶ形式になりますが、その時のドロップダウンメニューに表示される文字列
- `tooltip_text`: ボタンを hover した時に tooltip として表示される文字列

**ボタン形式**

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day20/channel-header-button-button.png)

**ドロップダウン形式**

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day20/channel-header-button-dropdown.png)

ここでは、先ほどの Root Comopnent を開く Button と、クリックすると投稿を作成する Button の 2 つの Button を表示する例を示します。投稿の作成は[mattermost-redux](https://github.com/mattermost/mattermost-redux)を使って投稿を作成する actions を作成し、Channel Header Button の action から呼び出しています。

![movie](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day20/channel-header-button.gif)

```js:index.js
import {openRootModal, createPluginPost} from './actions';
import reducer from './reducer';
import Root from './components/root';

...

export default class Plugin {
    // eslint-disable-next-line no-unused-vars
    initialize(registry, store) {
        // Root Componentの登録
        const rootComponentId = registry.registerRootComponent(Root)

        // Root Componentを呼び出すアクションの登録
        registry.registerChannelHeaderButtonAction(
            () => (<i className='icon fa fa-commenting-o' style={{fontSize: '15px', position: 'relative', top: '-1px'}}/>),
            () => store.dispatch(openRootModal()),
            "Open Root modal","Open Root modal"
		);

		...

        // 投稿を作成するチャンネルヘッダボタンを登録
        registry.registerChannelHeaderButtonAction(
            () => (<i className='icon fa fa-commenting-o' style={{fontSize: '15px', position: 'relative', top: '-1px'}}/>),
            (channel, channelMembers) => store.dispatch(createPluginPost(channel.id)),
            "Create Sample Post", "Create Sample Post"
        );

        registry.registerReducer(reducer);
    }
}
```

```js:actions.js
import {createPost} from 'mattermost-redux/actions/posts';
import {getCurrentUserId} from 'mattermost-redux/selectors/entities/users';

...

export function createPluginPost(channelId) {
    return async (dispatch, getState) => {
        const state = getState();
        const userId = getCurrentUserId(state)
        const post = {
            channel_id: channelId,
            user_id: userId,
            message: "Post from webapp plugin",
        }
        return await dispatch(createPost(post));
    }
}
```

### [registerPostTypeComponent](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerPostTypeComponent)

`registerPostTypeComponent`は、特定の type を持つ投稿をレンダリングする時に使用される Component を登録します。投稿（`Post`）に独自の type を指定する場合、その type は`custom_`で始まる必要があります。

登録した Component は以下の props を受け取れます。

- `post`: 投稿の内容 [post.go](https://github.com/mattermost/mattermost-server/blob/master/model/post.go#L72)
- `theme`: Mattermost 画面の配色テーマ [constants.jsx](https://github.com/mattermost/mattermost-webapp/blob/0b47780407e1f36e703df45e7fe694c7cf750244/utils/constants.jsx#L1047)

type に`custom_sample_post`を持つ投稿が作成された場合、背景色が赤の投稿をレンダリングする例を以下に示します。今回は、Incoming Webhook で投稿を作成する際のパラメータとして`custom_sample_post`の独自 type を指定しています。

```bash
curl \
  -H "Content-Type: application/json" \
  -d '{"type": "custom_sample_post", "text": "Sample Message", "props": {"card": "## Sample\n* foo\n* bar"}}'  \
  http://localhost:8065/hooks/ucw5qjw86jgeum77o1uw8197jr
```

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day20/post-type.png)

```js:index.js
...
import CustomPost from './components/custom_post';

export default class Plugin {
    // eslint-disable-next-line no-unused-vars
    initialize(registry, store) {
		...
        // type: custom_sample_post を持つ投稿をレンダリングするComponentの登録
		registry.registerPostTypeComponent('custom_sample_post', CustomPost);
	}
}
...
```

```js:components/custom_post.jsx
import React from 'react';
import PropTypes from 'prop-types';

const {formatText, messageHtmlToComponent} = window.PostUtils;

const CustomPostComponent = ({post, theme}) => {
    const formattedText = messageHtmlToComponent(formatText(post.message));

    console.log('theme', theme);
    return (
        <div style={{backgroundColor: '#ffcccc'}}>
            {formattedText}
            <pre>
                {JSON.stringify(post.props, null, 4)}
            </pre>
        </div>
    )
}

CustomPostComponent.propTypes = {
    post: PropTypes.object.isRequired,
    theme: PropTypes.object.isRequired,
};

export default CustomPostComponent;
```

独自の type を指定した投稿を作成した後に Plugin を無効にするなど、type に対応した Component が登録されていない場合は、通常の投稿と同じようにレンダリングされます。

### [registerPostCardTypeComponent](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerPostCardTypeComponent)

`registerPostCardTypeComponent`は、特定の type を持つ投稿の`card`要素をレンダリングする時に使用される Component を登録します。投稿（`Post`）に独自の type を指定する場合、その type は`custom_`で始まる必要があります。

登録した Component は以下の props を受け取れます。

- `post`: 投稿の内容 [post.go](https://github.com/mattermost/mattermost-server/blob/master/model/post.go#L72)
- `theme`: Mattermost 画面の配色テーマ [constants.jsx](https://github.com/mattermost/mattermost-webapp/blob/0b47780407e1f36e703df45e7fe694c7cf750244/utils/constants.jsx#L1047)

type に`custom_sample_card`を持つ投稿が作成された場合、背景色が青のカード要素を持つ投稿をレンダリングする例を以下に示します。`custom_sample_card`という独自 type は Incoming Webhook のパラメータとして指定しています。

```bash
curl \
  -H "Content-Type: application/json" \
  -d '{"type": "custom_sample_card", "text": "Sample Message", "props": {"card": "## Sample\n* foo\n* bar"}}'  \
  http://localhost:8065/hooks/ucw5qjw86jgeum77o1uw8197jr
```

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day20/post-card-type.png)

作成する投稿に`props.card`プロパティがない場合、`card`要素を表示するための`i`ボタンが表示されないためカード要素を表示することができません。必ず`props.card`要素を指定する必要があります。

```js:index.js
...
import CustomCard from './components/custom_card';

export default class Plugin {
    // eslint-disable-next-line no-unused-vars
    initialize(registry, store) {
		...
        // type: custom_sample_card を持つ投稿をレンダリングするComponentの登録
        registry.registerPostCardTypeComponent('custom_sample_card', CustomCard);
	}
}
...
```

```js:components/custom_card.jsx
import React from 'react';
import PropTypes from 'prop-types';

const {formatText, messageHtmlToComponent} = window.PostUtils;

const CustomCardComponent = ({post, theme}) => {
    const formattedText = messageHtmlToComponent(formatText(post.message));

    console.log('theme', theme);
    return (
        <div style={{backgroundColor: '#ccccff'}}>
            {formattedText}
            <pre>
                {JSON.stringify(post.props, null, 4)}
            </pre>
        </div>
    )
}

CustomCardComponent.propTypes = {
    post: PropTypes.object.isRequired,
    theme: PropTypes.object.isRequired,
};

export default CustomCardComponent;
```

独自の type を指定した投稿を作成した後に Plugin を無効にするなど、type に対応した Component が登録されていない場合は、通常の投稿と同じようにレンダリングされます。

### [registerPostWillRenderEmbedComponent ](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerPostWillRenderEmbedComponent)

`registerPostWillRenderEmbedComponent`は、投稿内で最初に出現する URL の内容をプレビュー表示する部分のコンポーネントを登録します。OpenGraph の情報を表示するアレです。

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day20/post-will-render-embed-sample.png)

`registerPostWillRenderEmbedComponent`は 3 つの引数を取ります。

- `match`: ここで指定したコンポーネントでプレビュー要素をレンダリングするかどうかを決定するための関数。プレビュー表示対象の URL や種別を使い、`true`を返すとここで指定したコンポーネントを使用する。
- `component`: プレビュー要素をレンダリングするコンポーネント
- `toggleable`: プレビュー要素を折り畳み可能にするかどうかのフラグ

また、登録した`Component`は以下の props を受け取れます。

- `embed`: 投稿の内容 [post.go](https://github.com/mattermost/mattermost-server/blob/master/model/post.go#L72)
  - `type`: `url`から取得できるプレビューの種別。`opengraph`や`image`などの値が入る
  - `url`: 投稿ないで最初に出現する URL
  - `data`: `url`から取得できるプレビュー内容に関する情報が格納されるらしいが、試している中では値が取得できなかった

`https://github.com/mattermost`で始まる URL が指定された場合に、青い背景色のプレビューをレンダリングする例を以下に示します。

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day20/post-will-render-embed.png)

```js:index.js
...
import CustomEmbed from './components/custom_embed';

export default class Plugin {
    // eslint-disable-next-line no-unused-vars
    initialize(registry, store) {
		...
        // 投稿に含まれるURLのプレビューをレンダリングするComponentの登録
        registry.registerPostWillRenderEmbedComponent(
            (embed) => embed.url && embed.url.startsWith(`https://github.com/mattermost/`),
            CustomEmbed,
            true
        );
    }
}
...
```

```js:components/custom_embed.jsx
import React from 'react';
import PropTypes from 'prop-types';

const CustomEmbedComponent = ({embed}) => {
    const {type, url, data} = embed;
    return (
        <div style={{backgroundColor: '#ccffcc'}}>
            <p>{type}</p>
            <p>{url}</p>
            <pre>
                {JSON.stringify(data, null, 4)}
            </pre>
        </div>
    )
}

CustomEmbedComponent.propTypes = {
    embed: PropTypes.shape ({
        type: PropTypes.string.isRequired,
        url: PropTypes.string.isRequired,
        data: PropTypes.object.isRequired,
    })
};

export default CustomEmbedComponent;
```

以下のリポジトリの`oEmbed-plugin`ブランチに、Mattermost 公式チームによる`registerPostWillRenderEmbedComponent`を使用したプラグインの実装が残っています。（作りかけで止まっているようですが）
https://github.com/mattermost/mattermost-plugin-oembed/tree/oEmbed-plugin

### [registerMainMenuAction](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerMainMenuAction)

`registerMainMenuAction`は、Mattermost のメインメニュー部分に独自のメニューを追加します。

`registerPostWillRenderEmbedComponent`は 3 つの引数を取ります。

- `text`: メインメニューに表示される文字列か React Element を指定します
- `action`: メインメニューが選択された際に実行されるアクションを登録します
- `mobileIcon`: モバイルアプリで表示されるアイコンを登録します（が、モバイルアプリだとメインメニュー表示されない...?）

モーダルを開くアクションが登録されたメインメニューを追加する例を以下に示します。

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day20/main-menu.gif)

```js:index.js
...
export default class Plugin {
    // eslint-disable-next-line no-unused-vars
    initialize(registry, store) {
		...
        // メインメニューを追加する
        registry.registerMainMenuAction(
            'Sample Main Menu',
            () => store.dispatch(openRootModal()),
            () => (<i className='icon fa fa-plug' style={{fontSize: '15px', position: 'relative', top: '-1px'}}/>)
        );
    }
}
...
```

### [registerChannelHeaderMenuAction](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerChannelHeaderMenuAction)

`registerChannelHeaderMenuAction`は、チャンネル名の部分をクリックした時に表示されるメニューに独自のメニューを追加します。

`registerPostWillRenderEmbedComponent`は 2 つの引数を取ります。

- `text`: メニューに表示される文字列か React Element
- `action`: メニューが選択された際に実行されるアクション。実行されたチャンネルのチャンネル ID が渡されます。

モーダルを開くアクションが登録されたチャンネルヘッダーメニューを追加する例を以下に示します。

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day20/channel-header-menu-action.gif)

```js:index.js
...
export default class Plugin {
    // eslint-disable-next-line no-unused-vars
    initialize(registry, store) {
		...
        // チャンネル名をクリックした際に表示されるメニューに独自メニューを追加する
        registry.registerChannelHeaderMenuAction(
            <i className='icon fa fa-plug' style={{fontSize: '15px', position: 'relative', top: '-1px'}}>{'Sample Menu'}</i>,
            (chnnelId) => store.dispatch(openRootModal())
        );
    }
}
...
```

### [registerPostDropdownMenuAction](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerPostDropdownMenuAction)

`registerPostDropdownMenuAction`は、投稿に対するドロップダウンメニューに独自のメニューを追加します。

`registerPostDropdownMenuAction`は 3 つの引数を取ります。

- `text`: メニューに表示される文字列か React Element
- `action`: メニューが選択された際に実行されるアクション。メニューが実行された投稿の PostID が渡されます。
- `filter`: メニューを表示するかどうかを決定する関数。実行された投稿の PostID が渡されます。

モーダルを開くアクションが登録されたドロップダウンメニューを追加する例を以下に示します。

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day20/post-dropdown-menu-action.gif)

```js:index.js
...
export default class Plugin {
    // eslint-disable-next-line no-unused-vars
    initialize(registry, store) {
		...
        // 投稿に対するドロップダウンメニューに独自メニューを追加する
        registry.registerPostDropdownMenuAction(
            <i className='icon fa fa-plug' style={{fontSize: '15px'}}>{'Sample Post Menu'}</i>,
            (postId) => store.dispatch(openRootModal()),
            (postId) => { return true; }
        );
    }
}
...
```

### [registerPostDropdownSubMenuAction](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerPostDropdownSubMenuAction)

`registerPostDropdownSubMenuAction`は、投稿に対するドロップダウンメニューにサブメニュー付きの独自のメニューを追加します。

まず、`registerPostDropdownSubMenuAction`は 3 つの引数を取ります。

- `text`: メニューに表示される文字列か React Element
- `action`: メニューが選択された際に実行されるアクション。実行された投稿の PostID が渡されます。(しかし、クリックしても何も実行されないようです)
- `filter`: メニューを表示するかどうかを決定する関数。メニューが実行された投稿の PostID が渡されます。

`registerPostDropdownSubMenuAction`は、返り値として登録したアクションの ID と、サブメニューを登録するための関数を返します。ここで返される関数を使ってサブメニューを登録していきますが、この関数は 2 つの引数を取ります。

- `text`: メニューに表示される文字列か React Element
- `action`: メニューが選択された際に実行されるアクション。メニューが実行された投稿の PostID が渡されます。

（サブメニューを登録する関数の第 3 引数として`filter`となる関数を渡しても、特に効果はないようです）

モーダルを開くアクションが登録されたドロップダウンサブメニューを追加する例を以下に示します。

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day20/post-dropdown-submenu.gif)

```js:index.js
...
export default class Plugin {
    // eslint-disable-next-line no-unused-vars
    initialize(registry, store) {
		...
        // 投稿に対するサブメニュー付きのドロップダウンメニューを追加する
        const {id, rootRegisterMenuItem} = registry.registerPostDropdownSubMenuAction(
            <i className='icon fa fa-plug' style={{fontSize: '15px'}}>{'Sample SubMenu'}</i>,
            (postId) => store.dispatch(openRootModal()),  // 実行されない
            (postId) => { return true; }
        );
        rootRegisterMenuItem(
            <i className='icon fa fa-plug' style={{fontSize: '15px'}}>{'SubMenu 1'}</i>,
            (postId) => store.dispatch(openRootModal()),
        );
        rootRegisterMenuItem(
            <i className='icon fa fa-plug' style={{fontSize: '15px'}}>{'SubMenu 2'}</i>,
            (postId) => store.dispatch(openRootModal())
        );
    }
}
...
```

### [registerPostDropdownMenuComponent](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerPostDropdownMenuComponent)

`registerPostDropdownMenuComponent`は、投稿に対するドロップダウンメニューに独自のコンポーネントを追加します。

登録した Component は以下の props を受け取れます。

- `postId`: アクションが実行された投稿の PostID
- `theme`: Mattermost 画面の配色テーマ [constants.jsx](https://github.com/mattermost/mattermost-webapp/blob/0b47780407e1f36e703df45e7fe694c7cf750244/utils/constants.jsx#L1047)
- `dispatch`: action を dispatch するための関数

モーダルを開くアクションが登録されたドロップダウンメニューを追加する例を以下に示します。

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day20/post-dropdown-component.gif)

```js:index.js
...
import CustomPostDropdown from './components/custom_post_dropdown';
...
export default class Plugin {
    // eslint-disable-next-line no-unused-vars
    initialize(registry, store) {
		...
        // 投稿に対するドロップダウンメニューにコンポーネントを登録する
        registry.registerPostDropdownMenuComponent(CustomPostDropdown);
		...
	}
}
```

```js:components/custom_post_dropdown.jsx
import React from 'react';
import PropTypes from 'prop-types';

import {openRootModal} from 'actions';

const CustomPostDropdownComponent = ({postId, theme, dispatch}) => {
    return (
        <div
            style={{backgroundColor: '#ffcccc'}}
            onClick={() => dispatch(openRootModal())}
        >
            {postId}
        </div>
    )
}

CustomPostDropdownComponent.propTypes = {
    postId: PropTypes.string.isRequired,
    theme: PropTypes.object.isRequired,
    dispatch: PropTypes.func.isRequired,
};

export default CustomPostDropdownComponent;
```

### [registerFileUploadMethod](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerFileUploadMethod)

`registerFileUploadMethod`は、ファイルアップロードメニューに独自のメニューを追加します。

`registerFileUploadMethod`は 3 つの引数を取ります。(公式ドキュメントは引数の順序が違っているので注意)

- `icon`: JSX 形式のメニューに表示されるアイコン
- `action`: メニューが選択された際に実行されるアクション。ファイルをアップロードするための関数が渡されます。
- `text`: メニューに表示されるテキスト

メニューが選択されると、テキストファイルが 2 つアップロードされる例を以下に示します。

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day20/file-upload-method.gif)

```js:index.js
...
export default class Plugin {
    // eslint-disable-next-line no-unused-vars
    initialize(registry, store) {
		...
        // ファイルアップロードメニューを追加する
        registry.registerFileUploadMethod(
            <i className='icon fa fa-pencil-square-o' style={{fontSize: '15px'}}/>,
            (upload) => upload([
                new File(["test1"], "sample1.txt"),
                new File(["test2"], 'sample2.txt')
            ]),
            'Sample File Upload'
        );
    }
}
...
```

### [registerFilesWillUploadHook](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerFilesWillUploadHook)

`registerFilesWillUploadHook`は、ファイルアップロード時に実行される関数を登録できます。

`registerFilesWillUploadHook`は 2 つの引数を取る関数を引数に取ります。

- `files`: アップロードしようとしているファイルの配列
- `upload`: ファイルをアップロードするための関数
  - この関数を使わなくとも、アップロードしたいファイルを返却値として指定することでファイルをアップロードできます

返り値として以下のフィールドを持つオブジェクトを返却する必要があります。

- `message`: 処理結果として画面に表示されるメッセージを指定します
- `files`: 処理結果としてアップロードするファイルを配列として指定します。`null`を指定するとアップロードを reject します。

2 つ以上のファイルを同時にアップロードしようとするとアップロードを reject する例を以下に示します。

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day20/files-will-upload-hook.gif)

```js:index.js
...
export default class Plugin {
    // eslint-disable-next-line no-unused-vars
    initialize(registry, store) {
		...

        // ファイルアップロード時の処理を登録する
        registry.registerFilesWillUploadHook((files, upload) => {
            let msg = '';
            if (files.length >= 2 ) {
                files = null;
                msg = 'Must upload one by one.';
            }
            return {
                message: msg,
                files: files,
            };
        });
    }
}
...
```

### [unregisterComponent](https://developers.mattermost.com/extend/plugins/webapp/reference/#unregisterComponent)

`unregisterComponent`は、プラグインとして登録した Component や Hook を登録から除外します。

`registerLeftSidebarHeaderComponent`によって登録したコンポーネントを登録から除外するメインメニューの例を以下に示します。

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day20/unregister-component.gif)

```js:index.js
...
export default class Plugin {
    // eslint-disable-next-line no-unused-vars
    initialize(registry, store) {
		...
        // 左サイドバーの上部に表示されるComponentの登録
        const leftSidebarHeaderComponentId = registry.registerLeftSidebarHeaderComponent(LeftSidebarHeader);
        ...
        // プラグインによって登録されたコンポーネントを登録から除外する
        registry.registerMainMenuAction(
            'Unregister LeftSideberHeader',
            () => registry.unregisterComponent(leftSidebarHeaderComponentId),
            () => (<i className='icon fa fa-plug' style={{fontSize: '15px', position: 'relative', top: '-1px'}}/>)
        );
    }
}
...
```

### [unregisterPostTypeComponent](https://developers.mattermost.com/extend/plugins/webapp/reference/#unregisterPostTypeComponent)

`unregisterPostTypeComponent`は、`unregisterComponent`と同様、独自の`PostType`に対して設定した Component を登録から除外します。

例は省略します。

### [registerReducer](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerReducer)

`registerReducer`は、プラグイン内で使用する Reducer を登録します。

ここまでに紹介してきた例では、モーダルを開くアクションが実行された場合などに`registerReducer`によって登録された reducer を利用しています。

```js:index.js
...
import reducer from './reducer';
...
export default class Plugin {
    // eslint-disable-next-line no-unused-vars
    initialize(registry, store) {
		...
        // Reducerを登録する
        registry.registerReducer(reducer);
    }
}
```

```js:reducer.js
import {combineReducers} from 'redux';

import {OPEN_ROOT_MODAL, CLOSE_ROOT_MODAL} from './action_types';

const rootModalVisible = (state = false, action) => {
    switch (action.type) {
    case OPEN_ROOT_MODAL:
        return true;
    case CLOSE_ROOT_MODAL:
        return false;
    default:
        return state;
    }
};

export default combineReducers({
    rootModalVisible,
});
```

```js:action_types.js
import {id as pluginId} from './manifest';

export const OPEN_ROOT_MODAL = pluginId + '_open_root_modal';
export const CLOSE_ROOT_MODAL = pluginId + '_close_root_modal';
```


## Webapp Plugin API

### [registerWebSocketEventHandler](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerWebSocketEventHandler)

`registerWebSocketEventHandler`は、Mattermost Server から送信される WebSocket イベントを処理する Handler を登録します。

`registerWebSocketEventHandler`は 2 つの引数を取ります。

- `event`: 処理する WebSocket イベントの種別
- `handler`: WebSocket イベントのデータを引数に取る関数。引数のデータはイベントによって異なります。

Server プラグインの[PublishWebSocketEvent](https://developers.mattermost.com/extend/plugins/server/reference/#API.PublishWebSocketEvent)と組み合わせて使用すると強力ですが、その辺りの例については 22 日目以降の記事で紹介します。

ここでは、Mattermost デフォルトの WebSocket イベントである投稿が作成された際に送信される`posted`イベントを受信した際に、投稿内容に`open modal`という文言が入っていた場合にモーダルを開く例を以下に示します。

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day21/websocket-event-handler.gif)

```js:index.js
...
import {openRootModal, createPluginPost} from './actions';
...
export default class Plugin {
    // eslint-disable-next-line no-unused-vars
    initialize(registry, store) {
		...
        // 'open modal'を含む投稿を受信するとモーダルを開く
        registry.registerWebSocketEventHandler(
            'posted',
            (event) => {
                const post = JSON.parse(event.data.post);
                if (post && post.message && post.message.includes('open modal')) {
                    store.dispatch(openRootModal());
                }
            }
        );
    }
}
```

### [unregisterWebSocketEventHandler](https://developers.mattermost.com/extend/plugins/webapp/reference/#unregisterWebSocketEventHandler)

`unregisterWebSocketEventHandler`は、`registerWebSocketEventHandler`によって WebSocket イベントに対して設定された Handler を登録から除外します。

例は省略します。

### [registerReconnectHandler](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerReconnectHandler)

`registerReconnectHandler`は、一度インターネット接続が失われた後に再び Mattermost へ接続した際に実行される Handler です。

`registerReconnectHandler`は引数のない関数を引数に取ります。

- `handler`: Mattermost へ再接続した際に実行される関数

例は省略します。

### [unregisterReconnectHandler](https://developers.mattermost.com/extend/plugins/webapp/reference/#unregisterReconnectHandler)

`unregisterReconnectHandler`は、`registerReconnectHandler`で登録した Handler を登録から除外します。引数は取りません。

こちらも例は省略します。

### [registerMessageWillBePostedHook](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerMessageWillBePostedHook)

`registerMessageWillBePostedHook`は、ユーザーが投稿を送信した際、その投稿がサーバーに送信される前に実行される処理を登録します。

`registerMessageWillBePostedHook`は、引数を 1 つ取ります。

- `hook`: ユーザーによって投稿処理が実行された際、その投稿がサーバーに送信される直前に実行される処理

`hooks`は、引数を一つ取ります。

- `post`: 投稿の情報

`hook`の返り値として、投稿情報を持つ`error`フィールドを含む値を返却した場合、投稿は reject されます。投稿情報を持つ`post`フィールドのを含むオブジェクトを返却した場合は、`post`フィールドの値で投稿が作成されます。

`忙しい`という文言を含む投稿を作成すると reject され、`帰りたい`という文言を含む投稿を作成すると`仕事したい`に変換される例を以下に示します。

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day21/message-will-be-posted-hook.gif)

```js:index.js
...
export default class Plugin {
    // eslint-disable-next-line no-unused-vars
    initialize(registry, store) {
		...
        // 投稿がサーバーに送信される前にrejectしたり内容を変換したりする
        registry.registerMessageWillBePostedHook(
            (post) => {
                if (post.message && post.message.includes('忙しい')) {
                    return {error: {message: '忙しくはないはずです'}};
                }
                post.message = post.message.replace(/帰りたい/gi, '仕事したい');
                return {post: post};
            }
        );
    }
}
```

### [registerSlashCommandWillBePostedHook](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerSlashCommandWillBePostedHook)

`registerSlashCommandWillBePostedHook`は、ユーザーが Slash Command を実行した際、その投稿がサーバーに送信される前に実行される処理を登録します。

`registerSlashCommandWillBePostedHook`は、引数を 1 つ取ります。

- `hook`: Slash Command が実行された際に、その内容がサーバーに送信される直前に実行される処理

`hook`は、引数を 2 つ取ります。

- `message`: 投稿されたメッセージ
- `args`: Slash Command 実行情報(`channel_id`, `team_id`, `root_id`, `parent_id`)

`/away`を reject、`/help`を`/shrug`に書き換え、`/leave`をエラーメッセージなしで reject するような処理を実行する例を以下に示します。

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day21/slash-command-will-be-posted-hook.gif)

```js:index.js
...
export default class Plugin {
    // eslint-disable-next-line no-unused-vars
    initialize(registry, store) {
		...
        // Slash Commandがサーバーに送信される前に実行される処理を追加する
        registry.registerSlashCommandWillBePostedHook(
            (message, args) => {
                console.log(message);
                if (message.startsWith('/away')) {
                    return {error: {message: 'rejected'}};
                }
                if (message.startsWith('/help')) {
                    console.log('help');
                    return {message: '/shrug converted from help command', args};
                }
                if (message.startsWith('/leave')) {
                    console.log('leave');
                    return {};
                }
            }
        );
    }
}
```

### [registerMessageWillFormatHook](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerMessageWillFormatHook)

`registerMessageWillFormatHook`は、投稿したメッセージが Markdown テキストとして変換される直前に実行される処理を登録します。

`registerMessageWillFormatHook`は、引数を 1 つ取ります。

- `hook`: 投稿が Markdown テキストとして変換される直前に実行される処理

`hook`は、引数を 2 つ取ります。

- `post`: 変換されていない投稿情報
- `message`: 投稿されたメッセージ（プラグインによって変換されている可能性あり）

`hook`の返却値として返された文字列が投稿として表示されます。

`registerMessageWillBePostedHook`は、投稿がサーバーに送信される前に投稿内容を編集するものでしたが、この`registerMessageWillFormatHook`は、投稿がサーバーに送信・保存された後にレンダリングされる際にメッセージを編集するものだと思われます。

良い利用方法が思いつかないので例は省略します。

### [registerFilePreviewComponent](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerFilePreviewComponent)

`registerFilePreviewComponent`は、ファイルプレビュー用の独自の Component を登録します。

`registerFilePreviewComponent`は、2 つの関数を引数に取ります。

- `override`: 独自のファイルプレビュー Component を使用するかどうかを決定するための関数。以下の 2 つを引数に取ります。
- `component`: ファイルプレビュー用の Component

`override`は、引数を 2 つ取ります。

- `fileInfo`: ファイルの情報
- `post`: 投稿の情報

`debug`で始まるメッセージを持つ投稿の添付ファイルをプレビューする際に、独自のコンポーネントを使用する例を以下に示します。

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day21/file-preview-component.gif)

```js:index.js
...
import CustomFilePreview from './components/custom_file_preview';
...
export default class Plugin {
    // eslint-disable-next-line no-unused-vars
    initialize(registry, store) {
		...
        // `debug`で始まるメッセージを持つ投稿の添付ファイルを独自コンポーネントでプレビューする
        registry.registerFilePreviewComponent(
            (fileInfo, post) => { return post.message && post.message.startsWith('debug'); },
            CustomFilePreview
        );
    }
}
```

```js:components/custom_file_preview.jsx
import React from 'react';
import PropTypes from 'prop-types';

const {formatText, messageHtmlToComponent} = window.PostUtils;

const CustomFilePreviewComponent = ({fileInfo, post}) => {
    const formattedText = messageHtmlToComponent(formatText(post.message));

    return (
        <div style={{backgroundColor: '#ffcccc'}}>
            {formattedText}
            <pre>
                {JSON.stringify(fileInfo, null, 4)}
            </pre>
        </div>
    )
}

CustomFilePreviewComponent.propTypes = {
    fileInfo: PropTypes.object.isRequired,
    post: PropTypes.object.isRequired,
};

export default CustomFilePreviewComponent;
```

### [registerTranslations](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerTranslations)

`registerTranslations`は、プラグイン内で使用しているメッセージの翻訳データを登録します。

`registerTranslations`は、`locale`を引数にとり、その`locale`に対する翻訳データを返す関数を引数に取ります。

RootModal 内のメッセージを日本語に翻訳する例を作ってみましたが、どうやら翻訳が正常に動作していない模様？

```js:index.js
...
import ja from 'i18n/';
...
export default class Plugin {
    // eslint-disable-next-line no-unused-vars
    initialize(registry, store) {
		...
        // 翻訳メッセージを登録する
        registry.registerTranslations((locale) => {
            switch (locale) {
            case 'en':
                return en;
            case 'ja':
                return ja;
            }
            return {};
        });
    }
}
```

```json:i18n/ja.json
{
    "rootModal.message": "ルートモーダル"
}
```

```js:components/root/root.jsx

import React from 'react';

import {FormattedMessage} from 'react-intl';

const Root = ({visible, close}) => {
    if (!visible) {
        return null;
    }

    const style = getStyle();

    return (
        <div
            style={style.backdrop}
            onClick={close}
        >
            <div style={style.modal}>
                <FormattedMessage
                    id='rootModal.message'
                    defaultMessage='Root Modal2'
                />
            </div>
        </div>
    );
};

Root.propTypes = {
    visible: PropTypes.bool.isRequired,
    close: PropTypes.func.isRequired,
};

const getStyle = () => ({
    backdrop: {
        position: 'absolute',
        display: 'flex',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.50)',
        zIndex: 2000,
        alignItems: 'center',
        justifyContent: 'center',
    },
    modal: {
        height: '300px',
        width: '500px',
        padding: '1em',
        color: 'black',
        backgroundColor: 'white',
    },
});

export default Root;
```

### [registerAdminConsolePlugin](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerAdminConsolePlugin)

`registerAdminConsolePlugin`は、AdminConsole(システムコンソール?)の内容を上書きするための関数を登録します。

Mattermost 内部での利用が主目的であり、ユーザープラグインによる使用は推奨されていないようなので例は省略します。（使い方がよく分からない）

### [unregisterAdminConsolePlugin](https://developers.mattermost.com/extend/plugins/webapp/reference/#unregisterAdminConsolePlugin)

`unregisterAdminConsolePlugin`は、`registerAdminConsolePlugin`で登録した　 AdminConsole 上書き用関数を登録から除外します。
`registerAdminConsolePlugin`が Mattermost 内部での利用が主目的のため、こちらも説明、例は省略します。

### [registerAdminConsoleCustomSetting](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerAdminConsoleCustomSetting)

`registerAdminConsoleCustomSetting`は、プラグイン用の設定画面に独自のコンポーネントを追加します。
このプラグイン API については、公式ドキュメントの[Best Practices](https://developers.mattermost.com/extend/plugins/best-practices/#how-can-a-plugin-define-its-own-setting-type)のページに詳細にまとめられています。

Mattermost Plugin では、マニフェストファイルの`settings_schema`という項目を指定することで、プラグイン専用の設定項目を作成することができます。

https://developers.mattermost.com/extend/plugins/manifest-reference/

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day21/admin-console-custom-settings-default.png)

デフォルトでは、下記の`type`を持つ設定項目を追加することができます。

- "bool": ラジオボタン (2 値)
- "dropdown": ドロップダウンメニュー
- "generated": 自動生成テキスト
- "radio": ラジオボタン (任意)
- "text": インプットボックス
- "longtext": 複数行テキスト
- "number": 数値入力欄
- "username":ユーザー名入力欄

デフォルトの`type`以外の設定項目を指定したい場合に`registerAdminConsoleCustomSetting`を使用します。

`registerAdminConsoleCustomSetting`は、3 つの引数を取ります。

- `key`: 上書きする設定項目の`key`。`key`は、マニフェストファイルに設定項目ごとに任意で指定する値です。
- `component`: 設定画面に表示される Component。
- `options`: 設定項目の表示方法についてのオプション
  - `showTitle`: `true`を指定した場合、マニフェストファイルの`display_name`が設定項目の左側に表示されます

パスワードなどを入力する際に、入力項目を UI 上に表示しないような設定項目を追加する例を以下に示します。

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day21/admin-console-custom-settings.png)

```json:plugin.json
{
    ...
    "settings_schema": {
        "settings": [
            {
                "key": "SampleSetting",
                "display_name": "Sample Setings Value",
                "type": "text",
                "help_text": "Sample",
                "default": "sample"
            }
        ]
    }
}
```

```js:index.js
...
import CustomSettings from './components/custom_settings';
...
export default class Plugin {
    // eslint-disable-next-line no-unused-vars
    initialize(registry, store) {
		...
        // 独自の設定画面項目を追加する
        registry.registerAdminConsoleCustomSetting(
            'SampleSetting',
            CustomSettings,
            {showTitle: true}
        );
    }
}
```

```js:components/custom_settings.jsx
import React from 'react';
import PropTypes from 'prop-types';

const CustomSettingsComponent = ({helpText, id, onChange, value}) => {
    const handleChange = (e) => {
        onChange(id, e.target.value);
    }
    return (
        <div style={{backgroundColor: '#ffcccc'}}>
            <input
              type={'password'}
              value={value}
              onChange={handleChange}
            />
            <pre>
                {JSON.stringify(helpText.props, null, 4)}
            </pre>
        </div>
    )
}

CustomSettingsComponent.propTypes = {
    helpText: PropTypes.shape ({
        props: PropTypes.object,
    }),
    id: PropTypes.string,
    onChange: PropTypes.func,
    value: PropTypes.any,
};

export default CustomSettingsComponent;
```

### [registerRightHandSidebarComponent](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerRightHandSidebarComponent)

`registerRightHandSidebarComponent`は、Mattermost の右サイドバーに表示する独自の Component を登録します。

`registerRightHandSidebarComponent`は、2 つの引数を取ります。

- `component`: 右サイドバーに表示される Component
- `title`: 右サイドバーのタイトル部分に表示されるテキスト

また、`registerRightHandSidebarComponent`は 4 つの引数を返却します。

- `id`: 登録された Component の ID
- `showRHSPlugin`: 登録した Component を表示するためのアクション
- `hideRHSPlugin`: 登録した Component を非表示にするためのアクション
- `toggleRHSPlugin`: 登録した Component の表示/非表示を切り替えるアクション

登録した Component は、他のプラグイン API から`shorRHSPlugin`、`hideRHSPlugin`、`toggleRHSPlugin`のアクションを実行することで表示されるようになります。`RHS`は`RightHandSideber`の略です。

右サイドバーに独自の Component を表示するためのメニューをメインメニューに追加する例を以下に示します。

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day21/right-hand-sidebar.gif)

```js:index.js
...
import CustomRightHandSideber from './components/custom_rhs';
...
export default class Plugin {
    // eslint-disable-next-line no-unused-vars
    initialize(registry, store) {
		...
        // 右サイドバーに表示される独自Componentを登録する
        const {toggleRHSPlugin} = registry.registerRightHandSidebarComponent(CustomRightHandSideber, "Sample RHS")
        // 右サイドバーを表示するためのメインメニューを追加する
        registry.registerMainMenuAction(
            'Open RHS',
            () => store.dispatch(toggleRHSPlugin),
            () => (<i/>)
        );
    }
}
```

```js:components/custom_rhs.jsx
import React from 'react';
import PropTypes from 'prop-types';

const ComponentRightHandSidebar = ({theme}) => {
    return (
        <div style={{backgroundColor: '#ffcccc'}}>
            <pre>
                {JSON.stringify(theme, null, 4)}
            </pre>
        </div>
    )
}

ComponentRightHandSidebar.propTypes = {
    PluggableId: PropTypes.string.isRequired,
    theme: PropTypes.object.isRequired,
};

export default ComponentRightHandSidebar;
```

### [registerNeedsTeamRoute](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerNeedsTeamRoute)

`registerNeedsTeamRoute`は、チームごとにプラグイン専用の Route を追加します。プラグイン専用のエラー画面を作成したい場合などに使用するものだと思います。

`registerNeedsTeamRoute`は、2 つの引数を取ります。

- `route`: ルート文字列
- `comopnent`: `route`にアクセスされた際に呼び出される Component

`http://localhost:8065`で Mattermost が起動していて、`test`というチーム名のチームがあり、`sample.plugin`というプラグイン ID を持つプラグインがインストールされており、その中で`registerNeedsTeamRoute`の引数として`route="/subpath"`が指定されていた場合、`http://localhost:8065/test/sample.plugin/subpath`にアクセスすると、`component`に指定したコンポーネントが呼び出されます。

以下に例を示します。

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day21/needs-team-route.gif)

```js:index.js
...
import CustomTeamRoute from './components/custom_team_route';
...
export default class Plugin {
    // eslint-disable-next-line no-unused-vars
    initialize(registry, store) {
		...
        // 独自のRouteを追加する
        registry.registerNeedsTeamRoute('/', CustomTeamRoute)
    }
}
```

```js:components/custom_team_route.jsx
import React from 'react';
import PropTypes from 'prop-types';

import {Switch, Route} from 'react-router-dom';
import {getCurrentTeam} from 'mattermost-redux/selectors/entities/teams';
import {useSelector} from 'react-redux';

import {id} from 'src/manifest';

const CustomTeamRouteComponent = () => {
    const currentTeam = useSelector(getCurrentTeam);
    return (
        <Switch>
            <Route path={`/${currentTeam.name}/${id}/error`}>
                <h3>{'This is error page!'}</h3>
                <p>
                    <a href={`/${currentTeam.name}`}>Back to Top</a>
                </p>
            </Route>
            <Route>
                <h3>{'404 Not Found'}</h3>
                <p>
                    <a href={`/${currentTeam.name}`}>Back to Top</a>
                </p>
            </Route>
        </Switch>
    )
}

CustomTeamRouteComponent.propTypes = {
    pluggableId: PropTypes.object.isRequired,
    theme: PropTypes.object.isRequired,
};

export default CustomTeamRouteComponent;
```

### [registerCustomRoute](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerCustomRoute)

`registerCustomRoute`は、プラグイン専用の Route を追加します。

`registerNeedsTeamRoute`は、`/${team_name}/${plugin_id}/${route}`のようにチームごとに Route を追加する API でしたが、`registerCustomRoute`は`/plug/${plugin_id}/${route}`のように、Mattermost 全体としてプラグインごとに一つの Route を追加する API です。

使い方は`registerNeedsTeamRoute`とほぼ同じのため、例は省略します。

## その他

Mattermost Plugin Webapp 開発中に使える Plugin 開発用の便利機能がいくつかあります。その概要だけ紹介します。

### [Theme](https://developers.mattermost.com/extend/plugins/webapp/reference/#theme)

Mattermost Plugin API の中でも何度か出てきましたが、Webapp Plugin では Mattermost のテーマカラーを参照することができます。Mattermost ではユーザーごとにテーマカラーを変更することができるため、Webapp Plugin で UI の色を指定する場合は、ユーザーごとに見え方が異なることを考慮に入れる必要があります。

参考: [Mattermost のテーマ集 \- Qiita](https://qiita.com/kaakaa_hoe/items/45c8857589ccd822ab1a)

Mattermost で扱われるテーマカラー一覧は以下で紹介されています。

https://developers.mattermost.com/extend/plugins/webapp/reference/#theme

### [Exported Libraries and Functions](https://developers.mattermost.com/extend/plugins/webapp/reference/#exported-libraries-and-functions)

Mattermost Webapp Plugin は React.js を使用して開発しますが、React 開発によく使われるいくつかのライブラリは Mattermost 本体から`window`オブジェクトを介して取得できるようになっています。
取得できるライブラリは以下で紹介されています。

https://developers.mattermost.com/extend/plugins/webapp/reference/#exported-libraries-and-functions

また、`window`オブジェクトから参照できるライブラリとして`window.PostUtils`というのがありますが、これは Mattermost フォーマットのテキストを扱うための便利関数を持つオブジェクトです。

以下のようにすることで、@メンションなどを含む Markdown テキスト(`text`)をフォーマットして扱うことができます。

```js
const { formatText, messageHtmlToComponent } = window.PostUtils;

const text = "...";
const formattedText = messageHtmlToComponent(formatText(text));
```

https://developers.mattermost.com/extend/plugins/webapp/reference/#post-utils

### [Redux Action](https://developers.mattermost.com/extend/plugins/webapp/actions/))

Webapp 上で投稿やユーザー情報の取得などの Mattermost に対する何かしらの処理を実行する場合、[mattermost-redux](https://github.com/mattermost/mattermost-redux)という Redux ライブラリがあります。これは Mattermost 本体の Webapp でも利用されている公式の Javascript API のような位置付けのものです。

mattermost-redux はもちろん Mattermost Plugin 開発でも使用することができ、下記のページで使い方について紹介されています。

https://developers.mattermost.com/extend/plugins/webapp/actions/


## Mattermost Plugin のテスト

### Server 側のテスト

Mattermost Plugin の Server 側の機能を Mattermost を実際に起動することなくテストするには、[`plugintest`](https://github.com/mattermost/mattermost-server/tree/master/plugin/plugintest)パッケージを使用します。

[`plugintest`](https://github.com/mattermost/mattermost-server/tree/master/plugin/plugintest)パッケージを使用してテストを記述していく方法について、Mattermost 本体にある[プラグインテストのサンプルコード](https://github.com/mattermost/mattermost-server/blob/5122b9e2929dbf84e22f496ee97d007fa18f2d2e/plugin/plugintest/example_hello_user_test.go)を元に紹介します。Matterpoll プラグインも大部分はこれと同じ方式でテストが記述されています。

```go:plugin/plugintest/example_hello_user_test.go
...
type HelloUserPlugin struct {
	plugin.MattermostPlugin
}

func (p *HelloUserPlugin) ServeHTTP(context *plugin.Context, w http.ResponseWriter, r *http.Request) {
	userID := r.Header.Get("Mattermost-User-Id")
	user, err := p.API.GetUser(userID)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		p.API.LogError(err.Error())
		return
	}

	fmt.Fprintf(w, "Welcome back, %s!", user.Username)
}
...
```

[https://github.com/mattermost/mattermost-server/blob/5122b9e2929dbf84e22f496ee97d007fa18f2d2e/plugin/plugintest/example_hello_user_test.go#L21](https://github.com/mattermost/mattermost-server/blob/5122b9e2929dbf84e22f496ee97d007fa18f2d2e/plugin/plugintest/example_hello_user_test.go#L21)

Mattermost プラグインの本体は、`plugin.MattermostPlugin`が embedded された構造体です。ここでは、`HelloUserPlugin` 構造体がそれにあたります。この構造体を通じてプラグイン用の API を実行したり、Hook となるメソッドを実装したりすることで、サーバー側の動作を定義することができます。`HelloUserPlugin` では、プラグイン独自のエンドポイントを追加する [`ServeHTTP`](<[https://developers.mattermost.com/extend/plugins/server/reference/#Hooks.ServeHTTP](https://developers.mattermost.com/extend/plugins/server/reference/#Hooks.ServeHTTP)>) Hooks が実装され、その処理の中で `GetUser` API を実行してエンドポイントへアクセスしたユーザーの情報を取得し、そのユーザー名をレスポンスとして返しています。

この`ServeHTTP` Hooks をテストする場合、単に`HelloUserPlugin`構造体を生成して`ServeHTTP`メソッドを実行しただけだと、プラグイン API (`GetUser`) の実行部分で実際の Mattermost サーバーの機能を呼び出そうとしてしまいエラーとなってしまいます。

```go
	user, err := p.API.GetUser(userID)
```

`HelloUserPlugin` の `API` フィールドは、`plugin.MattermostPlugin` 構造体が持っていたフィールドであり、このフィールドを通して呼び出されるメソッドは Mattermost サーバーの処理に依存しているからです。Mattermost サーバーがない状態でテストを実行する場合、この`API`フィールドを入れ替える必要があります。

ここで、プラグイン用のテストメソッドとして定義されている [`Example`](https://github.com/mattermost/mattermost-server/blob/5122b9e2929dbf84e22f496ee97d007fa18f2d2e/plugin/plugintest/example_hello_user_test.go#L37) メソッドをみてみましょう。

```go
...
func Example() {
	t := &testing.T{}
	user :&model.User{                           ... (1)
		Id:       model.NewId(),
		Username: "billybob",
	}

	api := &plugintest.API{}                       ... (2)
	api.On("GetUser", user.Id).Return(user, nil)   ... (3)
	defer api.AssertExpectations(t)                ... (4)

	helpers := &plugintest.Helpers{}
	defer helpers.AssertExpectations(t)

	p := &HelloUserPlugin{}
	p.SetAPI(api)                                  ... (5)
	p.SetHelpers(helpers)

	w := httptest.NewRecorder()
	r := httptest.NewRequest("GET", "/", nil)
	r.Header.Add("Mattermost-User-Id", user.Id)
	p.ServeHTTP(&plugin.Context{}, w, r)           ... (6)
	body, err := ioutil.ReadAll(w.Result().Body)
	require.NoError(t, err)
	assert.Equal(t, "Welcome back, billybob!", string(body))
}
```

[https://github.com/mattermost/mattermost-server/blob/5122b9e2929dbf84e22f496ee97d007fa18f2d2e/plugin/plugintest/example_hello_user_test.go#L37](https://github.com/mattermost/mattermost-server/blob/5122b9e2929dbf84e22f496ee97d007fa18f2d2e/plugin/plugintest/example_hello_user_test.go#L37)

**(2)**で `plugintest.API` という構造体のインスタンスを生成し、生成されたインスタンスをテスト対象のプラグイン構造体 `HelloUserPlugin` へ `SetAPI` 関数を通じてセット **(5)** しています。 `plugintest.API`自体は、そのままでは何も処理を行わないため、`api.On` で特定の引数が与えられた時の処理をテスト側で実装しています **(3)**。

```go
    ...
	user :&model.User{                           ... (1)
		Id:       model.NewId(),
		Username: "billybob",
	}
	...
    api.On("GetUser", user.Id).Return(user, nil)   ... (3)
	defer api.AssertExpectations(t)                ... (4)
	...
```

上記のコードの場合、`user.Id` を引数として `GetUser` メソッドが呼び出された場合に **(1)** で定義された `user` を返却するようモックを定義しています。また、`defer api.AssertExpectations(t)` **(4)** を書いておくことで、テスト実行が終了した時に `api.On` で定義したモックが実行されていなかった場合にテストを失敗させることができます。

`HelloUserPlugin` では [`Helpers`](<[https://developers.mattermost.com/extend/plugins/server/reference/#Helpers](https://developers.mattermost.com/extend/plugins/server/reference/#Helpers)>)関数を利用していませんでしたが、`Helpers`のメソッドを利用している場合も `API` と同様に関数をモックすることができます。

最後に `httptest` パッケージを使って `ServeHTTP` Hook を呼び出し、レスポンスが想定通りであることをチェックしています。

```go
	w := httptest.NewRecorder()
	r := httptest.NewRequest("GET", "/", nil)
	r.Header.Add("Mattermost-User-Id", user.Id)
	p.ServeHTTP(&plugin.Context{}, w, r)           ... (6)
```

このように `plugintest` パッケージを使うことで 、Mattermost サーバーがない状況でも Mattermost プラグインの処理をテストできるようになります。あとは、とにかくパターンを網羅するケースを書き出すだけです。筋力です。

### Server 側のテスト(Store)

Matterpoll では Mattermost Plugin の Key Value ストアへのアクセスを抽象化した `store` パッケージを用意しています。テスト対象のメソッド内で Key Value ストアへのアクセスが必要な処理があった場合、プラグイン API の `KVSet`、`KVGet` などのメソッドを `plugintest` パッケージでモックすることも可能ですが、テスト記述が煩雑になるため、Matterpoll では [vektra/mockery](<[https://github.com/vektra/mockery](https://github.com/vektra/mockery)>) を使って `store.Store` インタフェースからモックを生成してテストを記述しています。この [vektra/mockery](<[https://github.com/vektra/mockery](https://github.com/vektra/mockery)>) は、Mattermost 本体の `plugintest` パッケージを生成するのにも使われているものです。

### Webapp 側のテスト

ここについては、Mattermost Plugin 特有のトピックというものはなく、開発した React Component に対して[`Jest`](<[https://jestjs.io/](https://jestjs.io/ja/)>) を使った snapshot テストを実装しています。

### CI

CI は CircleCI を使っており、Mattermost プラグイン用の CircleCI Orb を使って lint / build/ coverage / deploy を行っています。

[https://github.com/matterpoll/matterpoll/blob/master/.circleci/config.yml](https://github.com/matterpoll/matterpoll/blob/master/.circleci/config.yml)

カバレッジは [Codecov](https://codecov.io/gh/matterpoll/matterpoll) による PR へのコメントフィードバックを実施しています。

![](https://blog.kaakaa.dev/images/posts/advent-calendar-2020/day24/codecov/png)

## Checks

静的解析系のツールは Mattermost プラグインのテンプレートリポジトリ [mattermost/mattermost\-plugin\-starter\-template: Build scripts and templates for writing Mattermost plugins\.](https://github.com/mattermost/mattermost-plugin-starter-template) で定義されているものとベースは同じで、採用している linter やルールが少し異なるという感じです。

サーバー側は [golangci-lint](https://github.com/golangci/golangci-lint) を使っており設定ファイルは下記の通りです。

```yml:.golangci.yml
run:
  timeout: 5m
  modules-download-mode: readonly

linters-settings:
  goconst:
    min-len: 2
    min-occurrences: 2
  gofmt:
    simplify: true
  goimports:
    local-prefixes: github.com/matterpoll/matterpoll
  golint:
    min-confidence: 0.0
  govet:
    check-shadowing: true
    enable-all: true
  misspell:
    locale: US
  maligned:
    suggest-new: true

linters:
  disable-all: true
  enable:
    - bodyclose
    - deadcode
    - dogsled
    - errcheck
    - goconst
    - gocritic
    - gofmt
    - goimports
    - golint
    - gosec
    - gosimple
    - govet
    - ineffassign
    - interfacer
    - maligned
    - misspell
    - nakedret
    - scopelint
    - staticcheck
    - structcheck
    - stylecheck
    - typecheck
    - unconvert
    - unparam
    - unused
    - varcheck
    - whitespace

issues:
  exclude-rules:
    # Exclude some linters from running on tests files.
    - path: _test\.go
      linters:
        - dupl
        - goconst
        - scopelint # https://github.com/kyoh86/scopelint/issues/4
```

[https://github.com/matterpoll/matterpoll/blob/d4ffdbfd6dcdea359b7419e0baa3ab8aaa32e420/.golangci.yml](https://github.com/matterpoll/matterpoll/blob/d4ffdbfd6dcdea359b7419e0baa3ab8aaa32e420/.golangci.yml)

クライアント側は [ESLint](https://eslint.org/) を使っており、設定ファイルは下記の通りです。（長いためリンク先参照）

[https://github.com/matterpoll/matterpoll/blob/0b797025cfbf319c43464fcf457d4cdfe5086188/webapp/.eslintrc.json](https://github.com/matterpoll/matterpoll/blob/0b797025cfbf319c43464fcf457d4cdfe5086188/webapp/.eslintrc.json)

## 翻訳

Matterpoll のメッセージは翻訳可能な形式で管理されており、現在、下記の言語が利用可能です。

- English
- France
- German
- Japanese
- Korean
- Polish
- Simplified Chinese
- Spanish
- Traditional Chinese

言語の切り替えは、Mattermost 本体の設定に応じて実施されます。

Mattermost Plugin における翻訳処理の詳細については、Matterpoll の共同開発者である Hanzei による下記の記事で紹介されています。

[https://developers.mattermost.com/blog/localizing-matterpoll/](https://developers.mattermost.com/blog/localizing-matterpoll/)

### Server 側の翻訳

Server 側の翻訳機能は[go-i18n](https://github.com/nicksnyder/go-i18n)を使用しています。

翻訳対象のメッセージは、コード上では以下のように`go-i18n`の`i18n`パッケージの構造体として書かれています。

```go:server/plugin/command.go
...
HelpText: p.LocalizeWithConfig(l, &i18n.LocalizeConfig{
	DefaultMessage: &i18n.Message{
		ID:    "dialog.createPoll.setting.multi",
		Other: "The number of options that an user can vote on.",
	}}),
...
```

[https://github.com/matterpoll/matterpoll/blob/45f095875a98fb1d4f3f166851c86f41b987493e/server/plugin/command.go#L265](https://github.com/matterpoll/matterpoll/blob/45f095875a98fb1d4f3f166851c86f41b987493e/server/plugin/command.go#L265)

実際の翻訳を行う場合は、`go-i18n`のコマンドラインツールを使って、上記のような`i18n`の構造体として宣言されたメッセージを json ファイルに集約します。その辺りの手順については以下のドキュメントにまとめられています。

https://github.com/matterpoll/matterpoll/blob/master/CONTRIBUTING.md#translating-strings

`go-i18n`によって集約されたメッセージを各国のコントリビュータにローカライズしてもらうことで、翻訳されたメッセージが表示されるようになっています。
https://github.com/matterpoll/matterpoll/tree/45f095875a98fb1d4f3f166851c86f41b987493e/assets/i18n

### Webapp 側の翻訳

Matterpoll Plugin では、まだ Webapp 側の翻訳機能は実装されていませんが、Mattermost Plugin の機能としては実装できるようになっています。

Webapp 側の翻訳は、[`react-intl`](https://www.npmjs.com/package/react-intl)を使用しています。

```jsx
...
import {FormattedMessage} from 'react-intl';
...
        <FormattedMessage
            id='rootModal.message'
            defaultMessage='Root Modal2'
		/>
...
```

上記のようにコード内で使用されている翻訳対象のメッセージは、`make i18n-extract`で集約することができます。

```Makefile
...
## Extract strings for translation from the source code.
.PHONY: i18n-extract
i18n-extract:
ifneq ($(HAS_WEBAPP),)
ifeq ($(HAS_MM_UTILITIES),)
	@echo "You must clone github.com/mattermost/mattermost-utilities repo in .. to use this command"
else
	cd $(MM_UTILITIES_DIR) && npm install && npm run babel && node mmjstool/build/index.js i18n extract-webapp --webapp-dir $(PWD)/webapp
endif
endif
...
```

[https://github.com/matterpoll/matterpoll/blob/master/Makefile#L205](https://github.com/matterpoll/matterpoll/blob/master/Makefile#L205)

集約されたメッセージファイルを Mattermost Webapp Plugin API の[`registerTranslations`](https://developers.mattermost.com/extend/plugins/webapp/reference/#registerTranslations)で登録することで、Webapp 側のメッセージの翻訳ができるようになります。
